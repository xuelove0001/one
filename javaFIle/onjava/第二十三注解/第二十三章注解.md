==第二十三章注解==

​		==注解（也被称为元数据）==为我们在代码中添加信息提供了一种形式化的方式，使我 们可以在稍后的某个时刻更容易的使用这些数据。

​		注解在一定程度上是把元数据和源代码文件结合在一起的趋势所激发的，而不是保 存在外部文档。这同样是对像 C# 语言对于 Java 语言特性压力的一种回应。

​		注解是 Java 5 所引入的众多语言变化之一。它们提供了 Java 无法表达的但是你需 要完整表述程序所需的信息。因此，注解使得我们可以以编译器验证的格式存储程序的 额外信息。注解可以生成描述符文件，甚至是新的类定义，并且有助于减轻编写 “样板” 代码的负担。通过使用注解，你可以将元数据保存在 Java 源代码中。并拥有如下优势： 简单易读的代码，编译器类型检查，使用 annotation API 为自己的注解构造处理工具。 即使 Java 定义了一些类型的元数据，但是一般来说注解类型的添加和如何使用完全取 决于你。

注解的语法十分简单，主要是在现有语法中添加 @ 符号。Java 5 引入了前三种定 义在 java.lang 包中的注解：

1. • @Override：表示当前的方法定义将覆盖基类的方法。如果你不小心拼写错误，或 者方法签名被错误拼写的时候，编译器就会发出错误提示。
2. • @Deprecated：如果使用该注解的元素被调用，编译器就会发出警告信息。
3. • @SuppressWarnings：关闭不当的编译器警告信息。
4. • @SafeVarargs：在 Java 7 中加入用于禁止对具有泛型 varargs 参数的方法或构 造函数的调用方发出警告。
5. • @FunctionalInterface：Java 8 中加入用于表示类型声明为函数式接口。
6. 注解的元素在使用时表现为名-值对的形式，并且需要放置在 @UseCase 声明之后的 括号内。

==定义注解==

​		如下是一个注解的定义。注解的定义看起来很像接口的定义。事实上，它们和其他 Java 接口一样，也会被编译成 class 文件

​		除了 @ 符号之外，@Test 的定义看起来更像一个空接口。注解的定义也需要一些 元注解（meta-annotation），比如 @Target 和 @Retention。@Target 定义你的注解可以 应用在哪里（例如是方法还是字段）。@Retention 定义了注解在哪里可用，在源代码中 （SOURCE），class 文件（CLASS）中或者是在运行时（RUNTIME）。

​		注解通常会包含一些表示特定值的元素。当分析处理注解的时候，程序或工具可以 利用这些值。注解的元素看起来就像接口的方法，但是可以为其指定默认值。

​		不包含任何元素的注解称为标记注解（marker annotation），例如上例中的 @Test 就是标记注解。

​		注解的元素在使用时表现为名-值对的形式，并且需要放置在 @UseCase 声明之后的 括号内。

==元注解==

​		Java 语言中目前有 5 种标准注解（前面介绍过），以及 5 种元注解。元注解用于注 解其他的注解

   				1. ==@Target== 表示注解可以用于哪些地方。可能的 **ElementType** 参数包括：
          				1.  CONSTRUCTOR：构造器的声明 
          				2. FIELD：字段声明（包括 enum 实例）
          				3. LOCAL_VARIABLE：局部变量声明 
          				4. METHOD：方法声 明 
          				5. PACKAGE：包声明 
          				6. PARAMETER：参数声明 
          				7. TYPE：类、 接口（包括注解类型）或者 enum 声明
   				2. ==@Retention== 表示注解信息保存的时长。可选的 RetentionPolicy 参数包括： 
          				1. SOURCE：注解将被编译器丢弃 
          				2. CLASS：注解在 class 文件中可 用，但是会被 VM 丢弃。
          				3. RUNTIME：VM 将在运行期也保留注解， 因此可以通过反射机制读取注解的信息。
   				3. ==@Documented== 将此注解保存在 Javadoc 中
   				4. ==@Inherited== 允许子类继承父类的注解
   				5. ==@Repeatable== 允许一个注解可以被使用一次或者多次（Java 8）。

==编写注解处理器==

​		如果没有用于读取注解的工具，那么注解不会比注释更有用。使用注解中一个很重 要的部分就是，创建与使用注解处理器。。Java 拓展了反射机制的 API 用于帮助你创造 这类工具。同时他还提供了 javac 编译器钩子在编译时使用注解。

==注解元素==

​		在 UseCase.java 中定义的 @UseCase 的标签包含 int 元素 id 和 String 元素 description。注解元素可用的类型如下所示：

 • 所有基本类型（int、float、boolean 等） 

• String       • Class 		• enum  		• Annotation 		• 以上类型的数组

==默认值限制==

​		编译器对于元素的默认值有些过于挑剔。首先，元素不能有不确定的值。也就是说， 元素要么有默认值，要么就在使用注解时提供元素的值。

​		这里有另外一个限制：任何非基本类型的元素，无论是在源代码声明时还是在注解 接口中定义默认值时，都不能使用 null 作为其值。这个限制使得处理器很难表现一个 元素的存在或者缺失的状态，因为在每个注解的声明中，所有的元素都存在，并且具有 相应的值。**为了绕开这个约束，可以自定义一些特殊的值，比如空字符串或者负数用于 表达某个元素不存在。**

```java
//这是一个在定义注解的习惯用法。
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface SimulatingNull {
    int id() default -1;

    String description() default " ";
}
```

==生成外部文件==

​		当有些框架需要一些额外的信息才能与你的源代码协同工作，这种情况下注解就会 变得十分有用。

		1. @Constraints 注解允许处理器提供数据库表的元数据。
		1. 如果你在注解中定义了名为 value 的元素，并且在使用该注解时，value 为唯一一个需要赋值的元素，你就不需要使用 名—值对的语法，你只需要在括号中给出 value 元素的值即可。这可以应用于任何合法 类型的元素。这也限制了你必须将元素命名为 value，
		1. 

==替代方案==

​		第三种可行的方案是一起使用两个注解，@Constraints 和相应的 SQL 类型（例 如，@SQLInteger）去注解同一个字段。这可能会让代码有些混乱，但是编译器允许 你对同一个目标使用多个注解。在 Java 8，在使用多个注解的时候，你可以重复使用同 一个注解。

==注解不支持继承==

==实现处理器==

​		

==使用 javac 处理注解==

​		通过 javac，你可以通过创建编译时（compile-time）注解处理器在 Java 源文件上 使用注解，而不是编译之后的 class 文件。但是这里有一个重大限制：你不能通过处理 器来改变源代码。唯一影响输出的方式就是创建新的文件。

​		如果你的注解处理器创建了新的源文件，在新一轮处理中注解会检查源文件本身。 工具在检测一轮之后持续循环，直到不再有新的源文件产生。然后它编译所有的源文 件。

​		每一个你编写的注解都需要处理器，但是 javac 可以非常容易的将多个注解处理 器合并在一起。你可以指定多个需要处理的类，并且你可以添加监听器用于监听注解处 理完成后接到通知。

==最简单的处理器==

​		让我们开始定义我们能想到的最简单的处理器，只是为了编译和测试。如下是注解 的定义

==更复杂的处理器==

​		当你创建用于 javac 注解处理器时，你不能使用 Java 的反射特性，因为你处理的 是源代码，而并非是编译后的 class 文件。各种 mirror[ˆ3 ] 解决这个问题的方法是，通 过允许你在未编译的源代码中查看方法、字段和类型

==基于注解的单元测试==

​		单元测试是对类中每个方法提供一个或者多个测试的一种事件，其目的是为了有规 律的测试一个类中每个部分是否具备正确的行为。在 Java 中，最著名的单元测试工具 就是 JUnit。JUnit 4 版本已经包含了注解。在注解版本之前的 JUnit 一个最主要的问 题是，为了启动和运行 JUnit 测试，有大量的 “仪式” 需要标注。这种负担已经减轻了 一些，但是注解使得测试更接近 “可以工作的最简单的测试系统”。 在注解版本之前的 JUnit，你必须创建一个单独的文件来保存单元测试。通过注解， 我们可以将单元测试集成在需要被测试的类中，从而将单元测试的时间和麻烦降到了最 低。这种方式有额外的好处，就是使得测试私有方法和公有方法变的一样容易。 这个基于注解的测试框架叫做 @Unit。其最基本的测试形式，可能也是你使用的 最多的一个注解是 @Test，我们使用 @Test 来标记测试方法。测试方法不带参数，并 返回 boolean 结果来说明测试方法成功或者失败。你可以任意命名它的测试方法。同 时 @Unit 测试方法可以是任意你喜欢的访问修饰方法，包括 private。 要使用 @Unit，你必须导入 onjava.atunit 包，并且使用 @Unit 的测试标记为 合适的方法和字段打上标签（在接下来的例子中你会学到），然后让你的构建系统对编 译后的类运行 @Unit，下面是一个简单的例子

​				