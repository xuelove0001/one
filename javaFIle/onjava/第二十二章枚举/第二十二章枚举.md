==第二十二章枚举==

​		关键字 enum 可以将一组具名的值的有限集合创建为一种新的类型，而这些 具名的值可以作为常规的程序组件使用。这是一种非常有用的功能

==基本 enum 特性==



==将静态类型导入用于 enum==

	1. 使用 static import 能够将 enum 实例的标识符带入当前的命名空间，所以无需再 用 enum 类型来修饰 enum 实例。（注意，在定义 enum 的同一个文件中，这种技巧无法使用，如果是在默认包中定义 enum，这种技巧也无法使用）
	1. ​				

==方法添加==

​		除了不能继承自一个 enum 之外，我们基本上可以将 enum 看作一个常规的类。也 就是说我们可以向 enum 中添加方法。enum 甚至可以有 main() 方法。

1. 如果你打算定义自己的方法，那么必须在 enum 实例序列的最后添加一个分 号。

2. Java 要求你必须先定义 enum 实例。（如果在定义 enum 实例之前定义了任何 方法或属性，那么在编译时就会得到错误信息。）

3. enum 中的构造器与方法和普通的类没有区别

4. 一旦 enum 的定义结束，编译器就不允许我 们再使用其构造器来创建任何实例了。

5. 然而，在我们创建一个新的 enum 时，可以同时实现一个或多个接口

6. ```java
   古怪的语法 <T extends Enum<T» 表示 T 是一个 enum 实例。
   ```

7. 无法从 enum 继承子类有时很令人沮丧。这种需求有时源自我们希望扩展原 enum 中的元素，有时是因为我们希望使用子类将一个 enum 中的元素进行分组。(在一个接口的内部，创建实现该接口的枚举，以此将元素进行分组，可以达到将枚 举元素分类组织的目的。)

8. 由于不能从enum中删除或添加元素

9. 显然，EnumSet 可以应用于多过 64 个元素的 enum，所以我猜测，Enum 会在必 要的时候增加一个 long。

10. 我们并不能真的将 enum 实例作 为一个类型来使用（因为每个 enum 元素都是一 个 LikeClasses 类型的 static final 实例。）

9. enum中被被定于的方法可以被继承和被enum中的实例调用。

==覆盖 enum 的方法==

​		1. 编译器为你创建的 enum 类都继承自 Enum 类

==实现而非继承==

​		我们已经知道，所有的 enum 都继承自 Java.lang.Enum 类。由于 Java 不支持多重 继承，所以你的 enum 不能再继承其他类

==随机选择==

​		就像你在 CartoonCharacter.get() 中看到的那样，本章中的很多示例都需要从 enum 实例中进行随机选择。

==使用接口组织枚举==

==使用 EnumSet 替代 Flags==

​		Set 是一种集合，只能向其中添加不重复的对象。当然，enum 也要求其成员都是唯 一的，所以 enum 看起来也具有集合的行为。不过，由于不能从enum中删除或添加元素所以它只能算是不太有用的集合。		

​		使用 EnumSet 的优点是，它在说明一个 二进制位是否存在时，具有更好的表达能力，并且无需担心性能。

​		EnumSet 的基础是 long，一个 long 值有 64 位，而一个 enum 实例只需一位 bit 表 示其是否存在。

==使用 EnumMap==

​		EnumMap 是一种特殊的 Map，它要求其中的键（key）必须来自一个 enum，由 于 enum 本身的限制，所以 EnumMap 在内部可由数组实现。因此 EnumMap 的速度很 快，我们可以放心地使用 enum 实例在 EnumMap 中进行查找操作。不过，我们只能将 enum 的实例作为键来调用 put() 可方法，其他操作与使用一般的 Map 差不多。

​		与 EnumSet 一样，enum 实例定义时的次序决定了其在 EnumMap 中的顺序。 main() 方法的最后部分说明，enum 的每个实例作为一个键，总是存在的。但是， 如果你没有为这个键调用 put() 方法来存入相应的值的话，其对应的值就是 null。

==常量特定方法==

​	Java 的 enum 有一个非常有趣的特性即它允许程序员为 enum 实例编写方法，从 而为每个 enum 实例赋予各自不同的行为。要实现常量相关的方法，你需要为 enum 定 义一个或多个 abstract 方法，然后为每个 enum **实例实现该抽象方法 **

​	与使用匿名内部类相比较，定义常量相关方法的语法更高效、简洁

​	这个例子也展示了 EnumSet 了一些特性。因为它是一个集合，所以对于同一个元 素而言，只能出现一次，因此对同一个参数重复地调用 add0 方法会被忽略掉（这是正 确的行为，因为一个 bit 位开关只能 “打开” 一次），==同样地，向 EnumSet 添加 enum 实例的顺序并不重要，因为其输出的次序决定于 enum 实例定义时的次序。==

==使用 enum 的职责链==

​		在**职责链**（Chain of Responsibility）设计模式中，程序员以多种不同的方式来解决 一个问题，然后将它们链接在一起。我们先来描述一下邮件。邮件的每个关键特征都可以用 enum 来表示。

==使用 enum 的状态机==

​		枚举类型非常适合用来创建状态机。一个状态机可以具有有限个特定的状态，==它 通常根据输入，从一个状态转移到下一个状态，不过也可能存在瞬时状态（transient states），而一旦任务执行结束，状态机就会立刻离开瞬时状态。==

​		每个状态都具有某些可接受的输入，不同的输入会使状态机从当前状态转移到不同 的新状态。由于 enum 对其实例有严格限制，非常适合用来表现不同的状态和输入。一 般而言，每个状态都具有一些相关的输出。

