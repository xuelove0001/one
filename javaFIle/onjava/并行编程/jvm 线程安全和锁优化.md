jvm 线程安全和锁优化

1. 并发处理的广泛应用是Amdahl定律代替摩尔定律成为计算机性能发展源动力的根本原因，也是人 类压榨计算机运算能力的最有力武器。

13.1 概述

​		线程安全的概念：当多个线程同时访问一个对象时，如果不用考虑这些线程在运行时环境下 的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对 象的行为都可以获得正确的结果，那就称这个对象是线程安全的。”

​		如果把“调用这个对象的行为”限定为“单次调用”，这个定 义的其他描述能够成立的话，那么就已经可以称它是线程安全了。

为了更深入地理解线程安全，在这里我们可以不把线程安全当作一个非真即假的二元排他选项来 看待，而是按照线程安全的“安全程度”由强至弱来排序，我们[1]可以将Java语言中各种操作共享的数 据分为以下五类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。

   		 1. 不可变  在Java语言里面（特指JDK 5以后，即Java内存模型被修正之后的Java语言），不可变 （Immutable）的对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要再进行 任何线程安全保障措施。在第10章里我们讲解“final关键字带来的可见性”时曾经提到过这一点：只要 一个不可变的对象被正确地构建出来（即没有发生this引用逃逸的情况），那其外部的可见状态永远都 不会改变，永远都不会看到它在多个线程之中处于不一致的状态。“不可变”带来的安全性是最直接、 最纯粹的。（分为基本类型final 和对象，对象需要自身保证不可变，如String、枚举类型、Long和Double等数值包装类型）(保证对象行为不影响自己状态的途径有很多种，最简单的一种就是把对象里面带有状态的变量都 声明为final，这样在构造函数结束之后，它就是不可变的)
   		 2. 绝对线程安全
         		 1. Vector是一个线程安全的容器，			

3. 3.相对线程安全

   相对线程安全就是我们通常意义上所讲的线程安全，它需要保证对这个对象单次的操作是线程安 全的，我们在调用的时候不需要进行额外的保障措施，但是对于一些特定顺序的连续调用，就可能需 要在调用端使用额外的同步手段来保证调用的正确性

4. 4.线程兼容

   线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对 象在并发环境中可以安全地使用。我们平常说一个类不是线程安全的，通常就是指这种情况。Java类 库API中大部分的类都是线程兼容的，如与前面的Vector和HashTable相对应的集合类ArrayList和

5. 5.线程对立

   线程对立是指不管调用端是否采取了同步措施，都无法在多线程环境中并发使用代码。由于Java 语言天生就支持多线程的特性，线程对立这种排斥多线程的代码是很少出现的，而且通常都是有害 的，应当尽量避免。

==13.2.2 线程安全的实现方法==

​		1.互斥同步

​				互斥同步（Mutual Exclusion & Synchronization）是一种最常见也是最主要的并发正确性保障手 段。同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一条（或者是一些， 当使用信号量的时候）线程使用。而互斥是实现同步的一种手段，临界区（Critical Section）、互斥量 （Mutex）和信号量（Semaphore）都是常见的互斥实现方式。因此在“互斥同步”这四个字里面，互斥 是因，同步是果；互斥是方法，同步是目的。在Java里面，最基本的互斥同步手段就是synchronized关键字，这是一种块结构（Block Structured）的同步语法。

​				从功能上看，根据以上《Java虚拟机规范》对monitorenter和monitorexit的行为描述，我们可以得出 两个关于synchronized的直接推论，这是使用它时需特别注意的：

		1. ·被synchronized修饰的同步块对同一条线程来说是可重入的。这意味着同一线程反复进入同步块 也不会出现自己把自己锁死的情况。
		1. ·被synchronized修饰的同步块在持有锁的线程执行完毕并释放锁之前，会无条件地阻塞后面其他 线程的进入。这意味着无法像处理某些数据库中的锁那样，强制已获取锁的线程释放锁；也无法强制 正在等待锁的线程中断等待或超时退出。

==其中的 java.util.concurrent.locks.Lock接口便成了Java的另一种全新的互斥同步手段。==基于Lock接口，用户能够 以非块结构（Non-Block Structured）来实现互斥同步，从而摆脱了语言特性的束缚，改为在类库层面 去实现同步，这也为日后扩展出不同调度算法、不同特征、不同性能、不同语义的各种锁提供了广阔 的空间。

在基本用法上，ReentrantLock也与synchronized很相似，只是代码写法上稍有区别而已。不 过，ReentrantLock与synchronized相比增加了一些高级功能，主要有以下三项：等待可中断、可实现公 平锁及锁可以绑定多个条件。

		1. ·等待可中断：是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改 为处理其他事情。可中断特性对处理执行时间非常长的同步块很有帮助。
		1. ·公平锁：是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁；而非公平 锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。synchronized中的锁是非 公平的，ReentrantLock在默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平 锁。不过一旦使用了公平锁，将会导致ReentrantLock的性能急剧下降，会明显影响吞吐量。
		1. ·锁绑定多个条件：是指一个ReentrantLock对象可以同时绑定多个Condition对象。在synchronized 中，锁对象的wait()跟它的notify()或者notifyAll()方法配合可以实现一个隐含的条件，如果要和多于一 个的条件关联的时候，就不得不额外添加一个锁；而ReentrantLock则无须这样做，多次调用 newCondition()方法即可。

2.非阻塞同步

​		互斥同步（不好的地方）面临的主要问题是进行线程阻塞和唤醒所带来的性能开销，因此这种同步也被称为阻塞 同步（Blocking Synchronization）。

​		随着硬件指令集的发展，我们已经有了另外一个选择：基于冲突检测的乐观并发策略，通俗地说 就是不管风险，先进行操作，如果没有其他线程争用共享数据，那操作就直接成功了；如果共享的数 据的确被争用，产生了冲突，那再进行其他的补偿措施，最常用的补偿措施是不断地重试，直到出现 没有竞争的共享数据为止。这种乐观并发策略的实现不再需要把线程阻塞挂起，因此这种同步操作被 称为非阻塞同步（Non-Blocking Synchronization），使用这种措施的代码也常被称为无锁（Lock-Free） 编程。这类指令常用的有：·测试并设置（Test-and-Set）获取并增加（Fetch-and-Increment）；·交换（Swap）·比较并交换（Compare-and-Swap，下文称CAS）；·加载链接/条件储存（Load-Linked/Store-Conditional，下文称LL/SC）。

3.无同步方案

​		要保证线程安全，也并非一定要进行阻塞或非阻塞同步，同步与线程安全两者没有必然的联系

​		