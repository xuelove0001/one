高效并发：

	1. Java内存模型与线程
	1. 

二： 概述

​		

原子性、可见性与有序性

1. 原子性 由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store和write这六个， 我们大致可以认为，基本数据类型的访问、读写都是具备原子性的（例外就是long和double的非原子性 协定，读者只要知道这件事情就可以了，无须太过在意这些几乎不会发生的例外情况）。
2. 可见性就是指当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改。。Java内存模型是通过在变量修改后将新值同步回主内 存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的，无论是 普通变量还是volatile变量都是如此。==除了volatile之外，Java还有两个关键字能实现可见性，它们是synchronized和final。==同步块的可见 性是由“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操 作）”这条规则获得的。而final关键字的可见性是指：被final修饰的字段在构造器中一旦被初始化完 成，并且构造器没有把“this”的引用传递出去（this引用逃逸是一件很危险的事情，其他线程有可能通 过这个引用访问到“初始化了一半”的对象），那么在其他线程中就能看见final字段的值。如代码清单 12-7所示，变量i与j都具备可见性，它们无须同步就能被其他线程正确访问。
3. 有序性（Ordering） （是相对的） Java内存模型的有序性在前面讲解volatile时也比较详细地讨论过了，Java程序中天然的有序性可以 总结为一句话：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程， 所有的操作都是无序的。前半句是指“线程内似表现为串行的语义”（Within-Thread As-If-Serial Semantics），后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。          Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性，volatile关键字本 身就包含了禁止指令重排序的语义，而synchronized则是由“一个变量在同一个时刻只允许一条线程对 其进行lock操作”这条规则获得的，这个规则决定了持有同一个锁的两个同步块只能串行地进入。

先行发生原则： 先行发生是Java内存模型中定义的两项操作之间的偏 序关系，比如说操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响能被操作B 观察到，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等。

==发生线行的规则：==

​		下面是Java内存模型下一些“天然的”先行发生关系，这些先行发生关系无须任何同步器协助就已 经存在，可以在编码中直接使用。如果两个操作之间的关系不在此列，并且无法从下列规则推导出 来，则它们就没有顺序性保障，虚拟机可以对它们随意地进行重排序。

		1. 程序次序规则： 在一个线程内，按照控制流顺序，书写在前面的操作先行 发生于书写在后面的操作。注意，这里说的是控制流顺序而不是程序代码顺序，因为要考虑分支、循 环等结构。
		1. ·管程锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作。这 里必须强调的是“同一个锁”，而“后面”是指时间上的先后
		1. ·volatile变量规则（Volatile Variable Rule）：对一个volatile变量的写操作先行发生于后面对这个变量 的读操作，这里的“后面”同样是指时间上的先后。
		1. ·线程启动规则（Thread Start Rule）：Thread对象的start()方法先行发生于此线程的每一个动作。
		1. ·线程终止规则（Thread Termination Rule）：线程中的所有操作都先行发生于对此线程的终止检 测，我们可以通过Thread::join()方法是否结束、Thread::isAlive()的返回值等手段检测线程是否已经终止 执行。
		1. ·线程中断规则（Thread Interruption Rule）：对线程interrupt()方法的调用先行发生于被中断线程 的代码检测到中断事件的发生，可以通过Thread::interrupted()方法检测到是否有中断发生。
		1. ·对象终结规则（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize()方法的开始。
		1. ·传递性（Transitivity）：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出 操作A先行发生于操作C的结论。

Java语言无须任何 同步手段保障  就能成立的先行发生规则有且只有上面这些

上面两个例子综合起来证明了一个结论：：时间先后顺序与先行发生原则之间基本没有因果关系， 所以我们衡量并发安全问题的时候不要受时间顺序的干扰，一切必须以先行发生原则为准。

==12.4 Java与线程==

​		并发不一定要依赖多线程，但在在Java中里面谈论并发，基本上都与线程脱离不开关系，

12.4.1 线程的实现

​		我们知道，线程是比进程更轻量级的调度执行单位，线程的引入，可以把一个进程的资源分配和 执行调度分开，各个线程既可以共享进程资源（内存地址、文件I/O等），又可以独立调度。目前线程 是Java里面进行处理器资源调度的最基本单位，不过如果日后Loom项目能成功为Java引入纤程 （Fiber）的话，可能就会改变这一点。

线程的调度：

​		1.Java使用的线程调度方式就是  抢占式 调度。在Windows 9x/NT内核中就是使用抢占式来实现多进程 的，当一个进程出了问题我们还可以使用任务管理器把这个进程杀掉，而不至于导致系统崩溃。		

12.4.3 状态转换

​		Java语言定义了6种线程状态，在任意一个时间点中，一个线程只能有且只有只有其中的一种状态，并且可以通过特定的方法在不同状态之间转换。这6种状态分别是：

  1. ·新建（New）：创建后尚未启动的线程处于这种状态。

  2. ·运行（Runnable）：包括操作系统线程状态中的Running和Ready，也就是处于此状态的线程有可 能正在执行，也有可能正在等待着操作系统为它分配执行时间。

  3. ·无限期等待（Waiting）：处于这种状态的线程不会被分配处理器执行时间，它们要等待被其他线 程显式唤醒。以下方法会让线程陷入无限期的等待状态：

     ■没有设置Timeout参数的Object::wait()方法；

     ■没有设置Timeout参数的Thread::join()方法

     ■LockSupport::park()方法。

  4. ·限期等待（Timed Waiting）：处于这种状态的线程也不会被分配处理器执行时间，不过无须等待 被其他线程显式唤醒，在一定时间之后它们会由系统自动唤醒。以下方法会让线程进入限期等待状 态：

     ■Thread::sleep()方法；

     ■设置了Timeout参数的Object::wait()方法；

     ■设置了Timeout参数的Thread::join()方法；

     ■LockSupport::parkNanos()方法；

     ■LockSupport::parkUntil()方法。

  5. ·阻塞（Blocked）：线程被阻塞了，“阻塞状态”与“等待状态”的区别是“阻塞状态”在等待着获取到 一个排它锁，这个事件将在另外一个线程放弃这个锁的时候发生；而“等待状态”则是在等待一段时 间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。

  6. ·结束（Terminated）：已终止线程的线程状态，线程已经结束执行。

上述6种状态在遇到特定事件发生的时候将会互相转换，

==12.5 Java与协程==

​		

==12.5.2 协程的复苏==   到后来，操作系统开始提供多线程的支持，靠应用自己模拟多线程的做法自然是变少了许多，但 也并没有完全消失，而是演化为用户线程继续存在。由于最初多数的用户线程是被设计成协同式调度 （Cooperative Scheduling）的，所以它有了一个别名——“协程”（Coroutine）。又由于这时候的协程会 完整地做调用栈的保护、恢复工作，所以今天也被称为“有栈协程”（Stackfull Coroutine），

==12.5.3 Java的解决方案==

​		对于有栈协程，有一种特例实现名为纤程（Fiber），这个词最早是来自微软公司，