第十章接口

   	接口和抽象类提供了一种将接口与实现分离的更加结构化的方法。

首先，我们将学习抽象类，一种介于普通类和接口之间的折中手段。尽管你的第一 想法是创建接口，但是对于构建具有属性和未实现方法的类来说，抽象类也是重要且必 要的工具。你不可能总是使用纯粹的接口。

==抽象类和方法==

​     在上一章的乐器例子中，基类 Instrument 中的方法往往是 “哑” 方法。如果调用 了这些方法，就会出现一些错误。这是因为接口的目的是为它的派生类创建一个通用接 口。

​	==什么是抽象类：就是派生类的共同部分。== 不==能被创建 或实例化 ，在编译时捕捉问题。它的声明没有方法体。==

​	==包含抽象方法的类叫做抽象类。如果一个类包含一个或多个抽象方法，那么类本身 也必须限定为抽象的，否则，编译器会报错。==	 

2. 如果新类继承抽象类就必须提供所有的方法定义，否则新类是抽象类
3. 抽象类可以不包含抽象方法，可以有其他方法，向阻止类的创建就很有用
4. 抽象类中的抽象方法的访问权限、你很快会看到接口自动将其方法指明为 public。事实上，接口只允许 public 方法，如果不加访问修饰符的话，接口的方法不 是 friendly 而是 public。（protected）
5. private abstract 被禁止了是有意义的，因为你不可能在 AbstractAccess 的任 何子类中合法地定义它。
6. 

​	==解释：==

​		如果一个抽象类是不完整的，当试图创建这个类的对象时，Java 会怎么做呢？它不 会创建抽象类的对象，所以我们只会得到编译器的错误信息。这样保证了抽象类的纯粹 性，我们不用担心误用它。

​	好处：

​		创建抽象类和抽象方法是有帮助的，==因为它们使得类的抽象性很明确，并能告知用 户和编译器使用意图。抽象类同时也是一种有用的重构工具，使用它们使得我们很容易 地将沿着继承层级结构上移公共方法。==

==接口==

==接口创建==:接口的基本概念仍然没变，介于类型之上、实现 之下。

​		使用 interface 关键字创建接口。在本书中，interface 和 class 一样随处常见，除 非特指关键字 interface，其他情况下都采用正常字体书写 interface。

​	接口的注意点：

	1. Java 知道这些方 法不能有方法体（仍然可以为方法加上 abstract 关键字,描述 Java 8 之前的接口更加容易，因为它们只允许抽象方法
	1. java8中在接口中定义了默认方法和静态方法（必须带修饰符default static），但是静态方法不能被继承
	1. 接口同样可以包含属性，这些属性被隐式指明为 static 和 final。public
	1. 接口的权限只有public 和包访问权限，
	1. 接口中仍然不允许存在属性（只有静态属 性）属性仍然只会来自单个基类或抽象类public static final 可以省略
	
		2. Java 8 中接口稍微有些变化，因为 Java 8 允许接口包含默认方法和静态方法——基 于某些重要原因，看到后面你会理解。
		2. 接口的基本概念仍然没变，介于类型之上、实现 之下。接口与抽象类最明显的区别可能就是使用上的惯用方式

在 Java 8 之前我们可以这么说：interface 关键字产生一个完全抽象的类， 没有提供任何实现。我们只能描述类应该像什么，做什么，但不能描述怎么做，即只能决定方法名、参数列表和返回类型，但是无法确定方法体。接口只提供形式，通常来说 没有实现，尽管在某些受限制的情况下可以有实现。

==接口和抽象类的区别：==

​	1.接口的典型使用是代表 一个类的类型或一个形容词，如 Runnable 或 Serializable，而抽象类通常是类层次结构 的一部分或一件事物的类型，如 String 或 ActionHero。

​	2.接口与抽象类最明显的区别可能就是使用上的惯用方式。

==接口的使用：==

​	1. 使用关键字 interface 而不是 class 来创建接口。

 	2. 和类一样，需要在关键字 interface 前加上 public 关键字（但只是在接口名与文件名相同的情况下），否则接口只有包访 问权限，只能在接口相同的包下才能使用它。

==默认方法：==

java8为关键字default增加了一个新的用途（之前只用于 switch 语句和注解 中）。==当在接口中使用它时，任何实现接口却没有定义方法的时候可以使用 default 创 建的方法体。==默认方法比抽象类中的方法受到更多的限制，但是非常有用，我们将在 “流式编程” 一章中看到。现在让我们看下如何使用：

​	==使用默认方法的好处：==

​	增加默认方法的极具说服力的理由是它允许在不破坏已使用接口的代码的情况下， 在接口中增加新的方法。默认方法有时也被称为**守卫方法或虚拟扩展方法**。

==静态方法：==

Java 8 允许在接口中添加静态方法。这么做能恰当地把工具功能置于接口中，从而 操作接口，或者成为通用的工具：

==完全解耦==

**当方法操纵的是一个类而非接口时**（参数是一个类或接口），它就只能作用于那个类或其子类。如果想把方 法应用于那个继承层级结构之外的类，就会触霉头。接口在很大程度上放宽了这个限 制，因而使用接口可以编写复用性更好的代码。

Applicator 的 apply() 方法可以接受任何类型的 Processor，并将其应用到一个 Object 对象上输出结果。像本例中这样，创建一个能根据传入的参数类型从而具备不 同行为的方法称为策略设计模式。方法包含算法中不变的部分，策略包含变化的部分。 策略就是传入的对象，它包含要执行的代码。在这里，Processor 对象是策略，main() 方法展示了三种不同的应用于 String s 上的策略。

组合接口

当打算组合接口时，在不同的接口中使用相同的方法名通常会造成代码可读性的混 乱，尽量避免这种情况。

接口的好处：

接口适配：

​     接口最吸引人的原因之一是相同的接口可以有多个实现。在简单情况下体现在一 个**方法接受接口作为参数**，该接口的实现和传递对象则取决于方法的使用者。 因此，接口的一种常见用法是前面提到的==**策略设计模式**==。编写一个方法执行某些操 作并接受一个指定的接口作为参数。可以说：“只要对象遵循接口，就可以调用方法” ， 这使得方法更加灵活，通用，并更具可复用性。

==接口字段==

因为接口中的字段都自动是 static 和 final 的，所以接口就成为了创建一组常量的 方便的工具。在 Java 5 之前，这是产生与 C 或 C++ 中的 enum (枚举类型) 具有相同 效果的唯一方式。

注意 Java 中使用大写字母的风格定义具有初始化值的 static final 变量。接口中 的字段自动是 public 的，所以没有显式指明这点。

==初始化接口中的字段==

​		接口中定义的字段不能是 “空 final”，但是可以用非常量表达式初始化。

```java
Random RAND = new Random(47); 
int RANDOM_INT = RAND.nextInt(10);
```

==因为字段是 static 的，所以它们在类第一次被加载时初始化，这发生在任何字段 首次被访问时。==

==这些字段不是接口的一部分，它们的值被存储在接口的静态存储区域中。==

==接口嵌套    接口可以嵌套在类或其他接口中。==

在类中嵌套接口的语法是相当显而易见的。就像非嵌套接口一样，它们具有 public 或包访问权限的可见性。

作为一种新添加的方式，接口也可以是 private 的

所 以实现 private 接口是一种可以强制该接口中的方法定义不会添加任何类型信息（即 不可以向上转型）的方式。

接口 E 说明了接口之间也能嵌套。然而，作用于接口的规则——尤其是，接口中 的元素必须是 public 的——在此都会被严格执行，所以嵌套在另一个接口中的接口自 动就是 public 的，不能指明为 private。

==接口和工厂方法模式==

接口是多实现的途径，而**生成符合某个接口的对象的**典型方式是**工厂方法设计模 式**。不同于直接调用构造器，只需调用工厂对象中的创建方法就能生成对象的实现—— 理论上，通过这种方式可以将接口与实现的代码完全分离，使得可以透明地将某个实现替换为另一个实现。这里是一个展示工厂方法结构的例子

如果没有工厂方法，代码就必须在某处指定将要创建的 Service 的确切类型，从而 调用恰当的构造器。 为什么要添加额外的间接层呢？一个常见的原因是创建框架。假设你正在创建一个 游戏系统；例如，在相同的棋盘下国际象棋和西洋跳棋：

建议：

==任何抽象性都应该是由真正的需求驱动的==恰当的原则是优先使用类而不是接口。从类开始，如果使用接口的必要性变得很明 确，那么就重构。接口是一个伟大的工具，但它们容易被滥用。