==第二十一章数组==

数组需要你去创建和初始化，你可以通过下标对数组元素进行访问，数 组的大小不会改变。

数组的特性：
		将数组和其他类型的集合区分开来的原因有三：

​		效率，类型，保存基本数据类型的 能力。在 Java 中，使用数组存储和随机访问对象引用序列是非常高效的。

==一等对象==

​	不管你使用的什么类型的数组，数组中的数据集实际上都是对堆中真正对象的引 用。数组是保存指向其他对象的引用的对象，数组可以隐式地创建，作为数组初始化语 法的一部分，也可以显式地创建，比如使用一个 new 表达式。数组对象的一部分（事 实上，你唯一可以使用的方法）就是只读的 length 成员函数，它能告诉你数组对象中 可以存储多少元素。[ ] 语法是你访问数组对象的唯一方式。

​	当你创建一个数组对象，其引用将自 动初始化为 null，因此你可以通过检查特定数组元素中的引用是否为 null 来判断其中 是否有对象。基元数组也有类似的机制，比如自动将数值类型初始化为 0，char 型初始 化为 (char)0，布尔类型初始化为 false。

==返回数组==

​		假设你写了一个方法，这个方法不是返回一个元素，而是返回多个元素。

==多维数组==

​		要创建多维的基元数组，你要用大括号来界定数组中的向量：

​		int[][] a = { { 1, 2, 3, }, { 4, 5, 6, }, };

​		int[][][] a = new int[2] [3] [4];

倘若你不对基元数组进行显式的初始化，它的值会自动初始化。而对象数组将被初 始化为 null 。

组成矩阵的数组中每一个向量都可以是任意长度的（这叫做不规则数组）		

==泛型数组==

		1. 一般来说，数组和泛型并不能很好的结合。
		1. 类型擦除需要删除参数类型信息，而且数组必须知道它们所保存的确切类型，以强 制保证类型安全。
		1. 你不能创建泛型类型的数组，这种说法并不完全正确。是的，编译器不会让你 实 例化一个泛型的数组。但是，它将允许您创建对此类数组的引用。例如：List<String>[] ls;
		1. 问题是数组是协变的，
		1. 因为数组实际上不真正支持而且 将对类型 T 动态检查。

==Arrays 的 setAll 方法==

​		它使用一个生成器并生成不同的值，可以选择基于数组的索引元素（通过访问 当前索引，生成器可以读取数组值并对其进行修改）。static Arrays.setAll() 的重载 签名为:

==增量生成==

​		