内部类：

​		一个定义在另一个类中的类，叫作内部类。

==介绍内部类==

​        内部类是一种非常有用的特性，因为它允许你把一些逻辑相关的类组织在一起，并 控制位于内部的类的可见性。然而必须要了解，内部类与组合是完全不同的概念，这一 点很重要。在最初，内部类看起来就像是一种代码隐藏机制：将类置于其他类的内部。你将会了解到，内部类远不止如此，它了解外部类，并能与之通信，而且你用内 部类写出的代码更加优雅而清晰，尽管并不总是这样（而且 Java 8 的 Lambda 表达式 和方法引用减少了编写内部类的需求）。

==创建内部类==

​	创建内部类的方式就如同你想的一样——把类的定义置于**外部类**的里面：

外部类创建内部类的对象：
	如果想从外部类的非静态方法之外的任意位置创建某个内部类的对象，那么必须像 在 main() 方法中那样，具体地指明这个对象的类型：OuterClassName.InnerClassName。 (译者注：在外部类的静态方法中也可以直接指明类型 InnerClassName，在其他类中需 要指明 OuterClassName.InnerClassName。)

链接外部类：

​	到目前为止，内部类似乎还只是一种名字隐藏和组织代码的模式。这些是很有用， 但还不是最引人注目的，它还有其他的用途。**当生成一个内部类的对象时，此对象与制 造它的外部对象（enclosing object）之间就有了一种联系，所以它能访问其外部对象的 所有成员，而不需要任何特殊条件。此外，内部类还拥有其外部类的所有元素的访问权。**

1. 内部类可以访问其外部 类的方法和字段，就像自己拥有它们似的，（**内部类自动拥有对其外部类所有成员的访问权**。）
2. 内部类的对象 只能在与其外部类的对象相关联的情况下才能被创建（就像你应该看到的，内部类是非 static 类时）。
3. 要想直接创建内部类的对象 必须使用外部类的对象来创建该内部类对象
4. 接口可以new但是要实现内部的方法（俗称内部类）
4. 普通内部类的字段与方法，只能放在类的外 部层次上，所以普通的内部类不能有 static 数据和 static 字段
4. 一个内部类被嵌套多少层并不重要——它能透明地访问所有它所嵌入的外部类的 所有成员
4. 

**内部类使用外部类的字段和方法的原理**：

​	当某个外 部类的对象创建了一个内部类对象时，此内部类对象必定==会秘密地捕获一个指向那个外部类对象的引用。==

==使用.this 和.new==

​		如果你需要生成对外部类对象的引用，可以使用外部类的名字后面紧跟圆点和 this。这样产生的引用自动地具有正确的类型，**这一点在编译期就被知晓并受到检查**， 因此没有任何运行时开销。下面的示例展示了如何使用 .this：

new 

​		有时你可能想要告知某些其他对象，去创建其某个内部类的对象。要实现此目的， 你必须在 new 表达式中提供对其他外部类对象的引用，这是需要使用 .new 语法，就 像下面这样：

​	

```java
public class DotNew {
public class Inner {}
public static void main(String[] args) {
DotNew dn = new DotNew();
    //要想直接创建内部类的对象 必须使用外部类的对象来创建该内部类对象
DotNew.Inner dni = dn.new Inner();
}
}
```

注意： static 和 普通类

​	在拥有外部类对象之前是不可能创建内部类对象的。这是因为内部类对象会暗暗 地连接到建它的外部类对象上。但是，如果你创建的是嵌套类（静态内部类），那么它 就不需要对外部类对象的引用。

==内部类与向上转型==

​		当将内部类向上转型为其==基类==。尤其是转型为一个接口的时候，内部类就有了用武 之地。

==内部类方法和作用域==（内部类被定义在哪里，就会作用域就会在哪里）

1.  可以在一个方法里面或者在任意的作 用域内定义内部类。
2. 在方法的作用域内（而不是在其他类的作用域内）创建一个完整 的类。这被称作局部内部类

==这么做有两个理由：==

		1. 你实现了某类型的接口，于是可以创建并返回对其的引用。
		1. 你要解决一个复杂的问题，想创建一个类来辅助你的解决方案，但是又不希望这 个类是公共可用的。

在后面的例子中，先前的代码将被修改，以用来实现：

	1. **一个定义在方法中的类**。并不意味着一旦 destination() 方法 执行完毕，PDestination 就不可用了。
	1. . 一个定义在作用域内的类，此作用域在方法的内部。（）
	1. 一个实现了接口的匿名类。
	1. 一个匿名类，它扩展了没有默认构造器的类。(可以构造 构造器)
	1. 一个匿名类，它执行字段初始化。在匿名类中定义字段时，还能够对其执行初始化操作 ，要求参数是final 这里省略掉 final 也没问题， 但是通常最好加上 final 作为一种暗示。**以保证数据的一致性**
	1. 一个匿名类，它通过实例初始化实现构造（匿名内部类不可能有构造器）。
	1. 

第一个例子展示了在方法的作用域内（而不是在其他类的作用域内）创建一个完整 的类。这被称作局部内部类：

==匿名内部类==

​		这个类是匿名的，它没有名字

​		这种奇怪的语法指的是：“创建一个继承自 Contents 的匿名类的对象。” 通过 **new 表达式返回的引用被自动向上转型为对 Contents 的引用**

​		在**匿名内部类末尾的分号**，并不是用来标记此内部类结束的。实际上，它标记 的是表达式的结束，**只不过这个表达式正巧包含了匿名内部类罢了**。因此，这与 别的地方使用的分号是一致的。

==嵌套类：==

​		如果不需要内部类对象与其外部类对象之间有联系，那么可以将内部类声明为 static，这通常称为**嵌套类**。想要理解 static 应用于内部类时的含义，就必须记住， **普通的内部类对象隐式地保存了一个引用**，指向创建它的外部类对象。然而，当内部类 是 static 的时，就不是这样了。嵌套类意味着：

​		 1. 要创建嵌套类的对象，并不需要其外部类的对象。 

​		2. 不能从嵌套类的对象中访问非静态的外部类对象。

==接口内部的类：==

​	嵌套类可以作为接口的一部分。**你放到接口中的==任何类都==自动地是 public 和 static 的**。

==使用==

​		如果你想要创建某些公共代码，使得它们可以被某个接口的所有不同实现所共用， 那么使用接口内部的嵌套类会显得很方便。

==为什么需要内部类==

​	==原因一==一般说来，内部类继承自某个类或实现某个接口，内部类的代码操作创建它的外部 类的对象。所以可以认为内部类提供了某种进入其外部类的窗口。

​	==原因二==

​	如果没有内部类提供的、可以继承多个具体的或抽象的类的能力，，**内部类允许继承多个非接 口类型（译注：类或抽象类）。**

==还可以获得其他一些特性：==

	1. 内部类可以有多个实例，每个实例都有自己的状态信息，并且与其外部类对象的 信息相互独立。
	1. 在单个外部类中，可以让多个内部类以不同的方式实现同一个接口，或继承同一 个类。稍后就会展示一个这样的例子。
	1. 创建内部类对象的时刻并不依赖于外部类对象的创建
	1. 内部类并没有令人迷惑的 “is-a” 关系，它就是一个独立的实体。

==闭包与回调==

​	闭包（closure）是一个可调用的对象，它记录了一些信息，这些信息来自于创建 它的作用域。通过这个定义，可以看出内部类是面向对象的闭包，因为它不仅包含外部 类对象（创建内部类的作用域）的信息，还自动拥有一个指向此外部类对象的引用，在 此作用域内，内部类有权操作所有的成员，包括 private 成员。

​	通过这个定义，可以看出内部类是面向对象的闭包，因为它不仅包含外部 类对象（创建内部类的作用域）的信息，还自动拥有一个指向此外部类对象的引用，在 此作用域内，内部类有权操作所有的成员，包括 private 成员。

​	==通过回调，对象能够携带一些信息，这些信息允许它在稍后的 某个时刻调用初始的对象。==

==闭包的好处==

​		通过内部类提供闭包的功能是优良的解决方案，它比指针更灵活、更安全。

==内部类与控制框架==

​		

==继承内部类==

​			因为内部类的构造器必须连接到指向其外部类对象的引用,问题在于，那个指向外部类对象的 “秘密的” 引用必须被初 始化，而在派生类中不再存在可连接的默认对象。

​			可以看到，InheritInner 只继承自内部类，而不是外部类。但是当要生成一个构 造器时，默认的构造器并不算好，而且不能只是传递一个指向外部类对象的引用。此外， 必须在构造器内使用如下语法： ==enclosingClassReference.super();== 这样才提供了必要的引用，然后程序才能编译通过。

==内部类可以被覆盖么？==

​			这个例子说明，**当继承了某个外部类的时候，内部类并没有发生什么特别神奇的变 化。这两个内部类是完全独立的两个实体，各自在自己的命名空间内**。当然，明确地继 承某个内部类也是可以的：

==局部内部类==

​		可以在代码块里创建内部类，典型的方式是在一个方法体的里面创 建。**局部内部类不能有访问说明符**，因为它不是外部类的一部分；但是它可以访问当前 代码块内的常量，以及此外部类的所有成员。下面的例子对局部内部类与匿名内部类的 创建进行了比较。

​		那为什么我们仍然使用局部内部类而不是匿名内部类呢？唯一的理由是，我们需要 一个已命名的构造器，或者需要重载构造器，而匿名内部类只能使用实例初始化。 所以使用局部内部类而不使用匿名内部类的另一个理由就是，需要不止一个该内部 类的对象。