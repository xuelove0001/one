第十九章类型信息

​			RTTI（RunTime Type Information，运行时类型信息）能够在程序运行时发 现和使用类型信息

​		RTTI 把我们从只能在编译期进行面向类型操作的禁锢中解脱了出来，并且让我们 可以使用某些非常强大的程序。对 RTTI 的需要，揭示了面向对象设计中许多有趣（并 且复杂）的特性，同时也带来了关于如何组织程序的基本问题。

本章将讨论 Java 是如何在运行时识别对象和类信息的。主要有两种方式：

​	\1. “传统的” RTTI：假定我们在编译时已经知道了所有的类型；

​	\2. “反射” 机制：允许我们在运行时发现和使用类的信息。

==为什么需要 RTTI==

​		draw() 方法在所有派生类里都会被覆盖， 而且由于它是动态绑定的，所以即使通过 Shape 引用来调用它，也能产生恰当的行为， 这就是多态。	==因 为在 Java 中，所有类型转换的正确性检查都是在运行时进行的。这也正是 RTTI 的含 义所在：在运行时，识别一个对象的类型。==通常，我们希望大部分代码尽可能少了解对象的具体类型，而是只与对象家族中 的一个通用表示打交道（本例中即为 Shape）。这样，代码会更容易写，更易读和维护； 设计也更容易实现，更易于理解和修改。所以多态是面向对象的基本目标。

1. • 编译期，stream 和 Java 泛型系统确保放入 stream 的都是 Shape 对象（Shape 子 类的对象也可视为 Shape 的对象），否则编译器会报错；
2. • 运行时，自动类型转换确保了从 stream 中取出的对象都是 Shape 类型。（接下来就是多态机制的事了）
3. 这时我们就希望知道 Stream 里边的形 状具体是什么类型，而 Java 实际上也满足了我们的这种需求。使用 RTTI，我们可以 查询某个 Shape 引用所指向对象的确切类型，然后选择或者剔除特例。

==Class 对象==

​		要理解 RTTI 在 Java 中的工作原理，首先必须知道类型信息在运行时是如何表示 的。这项工作是由称为 Class 对象的特殊对象完成的，它包含了与类有关的信息。实 际上，Class 对象就是用来创建该类所有 “常规” 对象的。<!--Java 使用 Class 对象来实现 RTTI-->，==即便是类型转换这样的操作都是用 Class 对象实现的。==

​		类是程序的一部分，每个类都有一个 Class 对象。换言之，每当我们编写并且编译 了一个新类，就会产生一个 Class 对象（更恰当的说，是被保存在一个同名的 .class 文件中）。为了生成这个类的对象，Java 虚拟机 (JVM) 先会调用 “类加载器” 子系统把 这个类加载到内存中。

==类加载器==

​		类加载器子系统可能包含一条类加载器链，但是有且只有一个原生类加载器，它是 JVM 实现的一部分。原生类加载器加载的是” 可信类（包括 Java API 类）。它们通常 是从本地盘加载的。在这条链中，通常不需要添加额外的类加载器，但是如果你有特殊 需求（例如以某种特殊的方式加载类，以支持 Web 服务器应用，或者通过网络下载类）， 也可以挂载额外的类加载器。

​	==所有的类都是第一次使用时动态加载到 JVM 中的，当程序创建第一个对类的静态 成员的引用时，就会加载这个类。==

​	其实构造器也是类的静态方法，虽然构造器前面并没有 static 关键字。所 以，使用 new 操作符创建类的新对象，这个操作也算作对类的静态成员引 用。

==特点：==

​		因此，Java 程序在它开始运行之前并没有被完全加载，很多部分是在需要时才会加 载。这一点与许多传统编程语言不同，动态加载使得 Java 具有一些静态加载语言（如 C++）很难或者根本不可能实现的特性。

​		类加载器首先会检查这个类的 Class 对象是否已经加载，如果尚未加载，默认的类 加载器就会根据类名查找 .class 文件（如果有附加的类加载器，这时候可能就会在数 据库中或者通过其它方式获得字节码）。这个类的字节码被加载后，JVM 会对其进行验 证，确保它没有损坏，并且不包含不良的 Java 代码 (这是 Java 安全防范的一种措施)。==一旦某个类的 Class 对象被载入内存==，它就可以用来创建这个类的所有对象。下 面的示范程序可以证明这点：

​		Candy、Gum 和 Cookie 这几个类都有一个 static{...} 静态初始 化块，这些静态初始化块在类第一次被加载的时候就会执行。也就是说，静态初始化块 会打印出相应的信息，告诉我们这些类分别是什么时候被加载了。而在主方法里边，创 建对象的代码都放在了 print() 语句之间，以帮助我们判断类加载的时间点。从输出中可以看到，Class 对象仅在需要的时候才会被加载，static 初始化是在 类加载时进行的。

```java
Class.forName("Gum");
```

​		所有 Class 对象都属于 Class 类，而且它跟其他普通对象一样，我们可以获取和 操控它的引用 (这也是类加载器的工作)。forName() 是 Class 类的一个静态方法，我 们可以使用 forName() 根据目标类的类名（String）得到该类的 Class 对象。果 Class.forName() 找不到要加载的类，它就会抛出异常 ClassNotFoundException。

​		无论何时，只要你想在运行时使用类型信息，就必须先得到那个 Class 对象的引 用。。Class.forName() 就是实现这个功能的一个便捷途径，因为使用该方法你不需要 先持有这个类型的对象。

==类字面常量==

​		Java 还提供了另一种方法来生成类对象的引用：类字面常量、类字面常量不仅可以应用于普通类，也可以应用于接口、数组以及基本数据类型。另外，对于基本数据类型的包装类，还有一个标准字段 TYPE。TYPE 字段是一个引用，指 向对应的基本数据类型的 Class 对象，

```java
…等价于…
boolean.class
Boolean.TYPE
char.class
Character.TYPE
byte.class
Byte.TYPE
short.class
Short.TYPE
int.class
Integer.TYPE
long.class
Long.TYPE
float.class
Float.TYPE
double.class
Double.TYPE
void.class
Void.TYPE
```

==注意==，有一点很有趣：当使用 .class 来创建对 Class 对象的引用时，不会自动地 初始化该 Class 对象。为了使用类而做的准备工作实际包含三个步骤：

1. 加载，这是由类加载器执行的。该步骤将查找字节码（通常在 classpath 所指定的 路径中查找，但这并非是必须的），并从这些字节码中创建一个 Class 对象。
2. 链接。在链接阶段将验证类中的字节码，为 static 字段分配存储空间，并且如果 需要的话，将解析这个类创建的对其他类的所有引用。
3. 初始化。如果该类具有超类，则先初始化超类，执行 static 初始化器和 static 初始化块。直到第一次引用一个 static 方法（构造器隐式地是 static）或者非常量的 static 字段，才会进行类初始化。
4. ==初始化有效地实现了尽可能的 “惰性”，从对 initable 引用的创建中可以看 到，仅使用 .class 语法来获得对类对象的引用不会引发初始化。==
5. 但与此相反，使用 Class.forName() 来产生 Class 引用会立即就进行初始化，
6. 如果一个 static final 值是 “编译期常量”（如 Initable.staticFinal），那么这 个值不需要对 Initable 类进行初始化就可以被读取。
7. 但是，如果只是将一个字段设置 成为 static 和 final，还不足以确保这种行为。例如，对 Initable.staticFinal2 的 访问将强制进行类的初始化，因为它不是一个编译期常量。
8. 如果一个 static 字段不是 final 的，那么在对它访问时，总是要求在它被读取之 前，要先进行链接（为这个字段分配存储空间）和初始化（初始化该存储空间），就像 在对 Initable2.staticNonFinal 的访问中所看到的那样。

==泛化的 Class 引用==

​		Class 引用总是指向某个 Class 对象，而 Class 对象可以用于产生类的实例，并 且包含可作用于这些实例的所有方法代码。它还包含该类的 static 成员，因此 Class 引用表明了它所指向对象的确切类型，而该对象便是 Class 类的一个对象。但是，Java 设计者看准机会，将它的类型变得更具体了一些。Java 引入泛型语法 之后，我们可以使用泛型对 Class 引用所指向的 Class 对象的类型进行限定。

==类引用==

​		普通的类引用不会产生警告信息。你可以看到，普通的类引用可以重新赋值指向任 何其他的 Class 对象，但是使用泛型限定的类引用只能指向其声明的类型。通过使用 泛型语法，我们可以让编译器强制执行额外的类型检查。

​		为了在使用 Class 引用时放松限制，我们使用了通配符，它是 Java 泛型中的一部 分。通配符就是 ?，表示 “任何事物”。

​		使用 Class 比单纯使用 Class 要好，虽然它们是等价的，并且单纯使用 Class 不会产生编译器警告信息。使用 Class 的好处是它表示你并非是碰巧或者由于疏忽 才使用了一个非具体的类引用，而是特意为之。

​		为了创建一个限定指向某种类型或其子类的 Class 引用，我们需要将通配符与 extends 关键字配合使用，创建一个范围限定。这与仅仅声明 Class 不同，现 在做如下声明：

​		向 Class 引用添加泛型语法的原因只是为了提供编译期类型检查，因此如果你操 作有误，稍后就会发现这点。使用普通的 Class 引用你要确保自己不会犯错，因为一旦 你犯了错误，就要等到运行时才能发现它，很不方便。

​		不管怎样，正是由于这种含糊性， up.newInstance 的返回值不是精确类型，

==cast() 方法==

​		Java 中还有用于 Class 引用的转型语法，即 cast() 方法：cast() 在无法使用普通类型转换的情况下会显得非常有用，只有一处使用了 cast()（在 com.sun.mirror.util.DeclarationFilter 中）。

没有特性：

​		Java 类库中另一个没有任何用处的特性就是 Class.asSubclass()，该方法允许你 将一个 Class 对象转型为更加具体的类型。

==类型转换检测==

		1.  传统的类型转换，如 “(Shape)”，由 RTTI 确保转换的正确性，如果执行了一个 错误的类型转换，就会抛出一个 ClassCastException 异常。
		1.  代表对象类型的 Class 对象. 通过查询 Class 对象可以获取运行时所需的信息.

==向下转型的原理：==

​		在 C++ 中，经典的类型转换 “(Shape)” 并不使用 RTTI。它只是简单地告诉编译 器将这个对象作为新的类型对待. 而 Java 会进行类型检查，这种类型转换一般被称作 “类型安全的向下转型”。之所以称作 “向下转型”，在编译期，编译器只能知道它 是 Shape。因此，你需要使用显式地进行类型转换，以告知编译器你想转换的特定类型， 否则编译器就不允许你执行向下转型赋值。（编译器将会检查向下转型是否合理，因此 它不允许向下转型到实际不是待转型类型的子类类型上）。

​	RTTI 在 Java 中还有第三种形式，那就是关键字 instanceof。它返回一个布尔值， 告诉我们对象是不是某个特定类型的实例，可以用提问的方式使用它，就像这个样子

```java
if(x instanceof Dog)
((Dog)x).bark();
```

==使用类字面量==

==注册工厂==



==类的等价比较==		

​		与类型的概念一致，instanceof 说的是 “你是这个类，还 是从这个类派生的类？”。而如果使用 == 比较实际的 Class 对象，则与继承无关 —— 它要么是确切的类型，要么不是。

==反射：运行时类信息==

​		如果你不知道对象的确切类型，RTTI 会告诉你。但是，有一个限制：必须在编译 时知道类型，才能使用 RTTI 检测它，并对信息做一些有用的事情。换句话说，编译器 必须知道你使用的所有类。

​		起初，这看起来并没有那么大的限制，但是假设你引用了一个不在程序空间中的对 象。实际上，该对象的类在编译时甚至对程序都不可用。也许你从磁盘文件或网络连接 中获得了大量的字节，并被告知这些字节代表一个类。由于这个类在编译器为你的程序 生成代码后很长时间才会出现，你如何使用这样的类？

==反射的要求==

​		通过在编程时设置这些组件的一些值 来配置这些组件。这种设计时配置要求任何组件都是可实例化的，它公开自己的部分， 并且允许读取和修改其属性。==反射提供了检 测可用方法并生成方法名称的机制。==

在运行时发现类信息的另一个令人信服的动机是提供跨网络在远程平台上创建和 执行对象的能力。这称为==远程方法调用==（RMI），它使 Java 程序的对象分布在许多机 器上。

==解释为啥用反射==

​		这种分布有多种原因。如果你想加速一个计算密集型的任务，你可以把它分解成 小块放到空闲的机器上。或者你可以将处理特定类型任务的代码（例如，多层次客户 机/服务器体系结构中的 “业务规则”）放在特定的机器上，这样机器就成为描述这些操 作的公共存储库，并且可以很容易地更改它以影响系统中的每个人。分布式计算还支持 专门的硬件，这些硬件可能擅长于某个特定的任务——例如矩阵转换——但对于通用编程来说不合适或过于昂贵。----------考虑一个类方法提取器。查看类定义的源代码或 JDK 文档，只显示在该类定义中 定义或重写的方法。但是，可能还有几十个来自基类的可用方法。找到它们既单调又费 时1。

==类 Class 支持反射的概念==

​		==java.lang.reflect 库中包含类 Field、Method 和 Constructor（每一个都实现了 Member 接口）。这些类型的对象由 JVM 在运行时创建， 以表示未知类中的对应成员==。然后，可以使用 Constructor 创建新对象，get() 和 set() 方法读取和修改与 Field 对象关联的字段，invoke() 方法调用与 Method 对象关联的 方法。还可以调用便利方法 getFields()、getMethods()、getConstructors() 等，以返回表示字段、方法和构造函数的对象数组。==匿名对象的类信息可以在运行时完全确定，编译时不 需要知道任何信息。==（例如：匿名内部类）

​		==重要的是要意识到反射没有什么魔力。==当你使用反射与未知类型的对象交互时， JVM 将查看该对象，并看到它属于特定的类（就像普通的 RTTI）在对其执行任何操 作之前，必须加载 Class 对象。因此，该特定类型的 .class 文件必须在本地计算机上 或通过网络对 JVM 仍然可用

==RTTI 和反射的真正区别在于==

​		使用 RTTI 时，编 译器在编译时会打开并检查.class 文件。通过反射，.class 文件在编译时不可用；它由运行时环境打开并 检查。

```java
/*
类方法提取器:
通常，你不会直接使用反射工具，但它们可以帮助你创建更多的动态代码。反射是
用来支持其他 Java 特性的，例如对象序列化（参见附录：对象序列化）。但是，有时动态提取有关类的信息很有用。
*/
```

==动态代理==

​		代理是基本的设计模式之一。一个对象封装真实对象，代替其提供其他或不同的操 作—这些操作通常涉及到与 “真实” 对象的通信，因此代理通常充当中间对象。这是一 个简单的示例，显示代理的结构：

​		因为 consumer() 接受 Interface，所以它不知道获得的是 RealObject 还是 SimpleProxy，因为两者都实现了 Interface。但是，在客户端和 RealObject 之间插 入的 SimpleProxy 执行操作，然后在 RealObject 上调用相同的方法。

==使用场景：==

​		当你希望将额外的操作与 “真实对象” 做分离时，代理可能会有所帮助，尤其是当 你想要轻松地启用额外的操作时，反之亦然（设计模式就是封装变更—所以你必须改变 一些东西以证明模式的合理性）。

==好处==

​		例如，如果你想跟踪对 RealObject 中方法的调用，或 衡量此类调用的开销，该怎么办？你不想这部分代码耦合到你的程序中，而代理能使你 可以很轻松地添加或删除它。

==更好的解析==

​		Java 的动态代理更进一步，不仅动态创建代理对象而且动态处理对代理方法的调 用。在动态代理上进行的所有调用都被重定向到==单个调用处理程序==，==该处理程序负责 发现调用的内容并决定如何处理==。这是 SimpleProxyDemo.java 使用动态代理重写的例 子

==反射的动态代理==

​		可以通过调用静态方法 Proxy.newProxyInstance() 来创建动态代理，该方法需要 一个类加载器（通常可以从已加载的对象中获取），希望代理实现的接口列表（不是类 或抽象类），以及接口 InvocationHandler 的一个实现。动态代理会将所有调用重定向 到调用处理程序，因此通常为调用处理程序的构造函数提供对 “真实” 对象的引用，以 便一旦执行中介任务便可以转发请求。 invoke() 方法被传递给代理对象，以防万一你必须区分请求的来源—但是在很多 情况下都无需关心。但是，在 invoke() 内的代理上调用方法时要小心，因为接口的调 用是通过代理重定向的。 通常执行代理操作，然后使用 Method.invoke() 将请求转发给被代理对象，并携 带必要的参数。这在一开始看起来是有限制的，好像你只能执行一般的操作。但是，可 以过滤某些方法调用，同时传递其他方法调用

==Optional 类==

​		如果你使用内置的 null 来表示没有对象，每次使用引用的时候就必须测试一下引 用是否为 null，这显得有点枯燥，而且势必会产生相当乏味的代码。问题在于 null 没什么自己的行为，只会在你想用它执行任何操作的时候产生 NullPointException。 java.util.Optional（首次出现是在函数式编程这章）为 null 值提供了一个轻量级代 理，Optional 对象可以防止你的代码直接抛出 NullPointException。==虽然 Optional 是 Java 8 为了支持流式编程才引入的，但其实它是一个通用的工 具。==

​		Optional 最有用武之地的是在那些 “更接 近数据” 的地方，在问题空间中代表实体的对象上。举个简单的例子，很多系统中都有 Person 类型，代码中有些情况下你可能没有一个实际的 Person 对象（或者可能有，但 是你还没用关于那个人的所有信息）。这时，在传统方法下，你会用到一个 null 引用， 并且在使用的时候测试它是不是 null。而现在，我们可以使用 Optional：

```java
class Person {
public final Optional<String> first;
public final Optional<String> last;
public final Optional<String> address;
// etc.
public final Boolean empty;
Person(String first, String last, String address) {
this.first = Optional.ofNullable(first);
this.last = Optional.ofNullable(last);
this.address = Optional.ofNullable(address);
empty = !this.first.isPresent()
&& !this.last.isPresent()
&& !this.address.isPresent();
}
```

​		Person 的设计有时候又叫 “==数据传输对象==（DTO，data-transfer object）”。注意，所 有字段都是 public 和 final 的，所以没有 getter 和 setter 方法。也就是说，Person是不可变的，你只能通过构造器给它赋值，之后就只能读而不能修改它的值（字符串本 身就是不可变的，因此你无法修改字符串的内容，也无法给它的字段重新赋值）。如果 你想修改一个 Person，你只能用一个新的 Person 对象来替换它。empty 字段在对象创 建的时候被赋值，用于快速判断这个 Person 对象是不是空对象。==如果想使用 Person，就必须使用 Optional 接口才能访问它的 String 字段，这样 就不会意外触发 NullPointException 了。==

​		同时，我们想保证 title 字段永远不会变成 null 值。为此，我们可以自己在 setTitle() 方法里边检查参数 newTitle 的值。

==标记接口==

​		有时候使用一个标记接口来表示空值会更方便。标记接口里边什么都没有，你只要 把它的名字当做标签来用就可以。

==Mock 对象和桩==

​		Mock 对象和 桩（Stub）在逻辑上都是 Optional 的变体他们、都是最终程序中 所使用的 “实际” 对象的代理。

​		不过，Mock 对象和桩都是假扮成那些可以传递实际信 息的实际对象，而不是像 Optional 那样把包含潜在 null 值的对象隐藏。

​		Mock 对象和桩之间的的差别在于程度不同。Mock 对象往往是轻量级的，且用于 自测试。通常，为了处理各种不同的测试场景，我们会创建出很多 Mock 对象。而桩只 是返回桩数据，它通常是重量级的，并且经常在多个测试中被复用。桩可以根据它们被 调用的方式，通过配置进行修改。因此，桩是一种复杂对象，它可以做很多事情。至于 Mock 对象，如果你要做很多事，通常会创建大量又小又简单的 Mock 对象。

==接口和类型==

​	解决不想被外部程序员用的代码和方法？ ==重点==

​		interface 关键字的一个重要目标就是允许程序员隔离组件，进而降低耦合度。使 用接口可以实现这一目标，但是通过类型信息，这种耦合性还是会传播出去——接口并 不是对解耦的一种无懈可击的保障。

​		这样的操作完全是合情合理的，但是你也许并不想让客户端开发者这么做，因为这 给了他们一个机会，使得他们的代码与你的代码的耦合度超过了你的预期。也就是说， 你可能认为 interface 关键字正在保护你，但其实并没有。

​		一种解决方案是直接声明，如果开发者决定使用实际的类而不是接口，他们需要自 己对自己负责。这在很多情况下都是可行的，但 “可能” 还不够，你或许希望能有一些 更严格的控制方式。

​		最简单的方式是让实现类只具有包访问权限，这样在包外部的客户端就看不到它 了：

​		在这个包中唯一 public 的部分就是 HiddenC，在被调用时将产生 A 接口类型的对 象。这里有趣之处在于：即使你从 makeA() 返回的是 C 类型，你在包的外部仍旧不能 使用 A 之外的任何方法，因为你不能在包的外部命名 C。 现在如果你试着将其向下转型为 C，则将被禁止，因为在包的外部没有任何 C 类型 可用（但是通过反射还是可以调用其他方法）

​		正如你所看到的，通过使用反射，仍然可以调用所有方法，甚至是 private 方法！ 如果知道方法名，你就可以在其 Method 对象上调用 setAccessible(true)，就像在 callHiddenMethod() 中看到的那样。

​		你可能觉得，可以通过==只发布编译后==的代码来阻止这种情况，但其实这并不能解决 问题。因为只需要运行 javap（一个随 JDK 发布的反编译器）即可突破这一限制。下 面是一个使用 javap 的命令行：javap -private C(类名)

​		-private 标志表示所有的成员都应该显示，甚至包括私有成员

​		那如果把接口实现为一个私有内部类，又会怎么样呢？这里对反射仍然没有任何东西可以隐藏。那么如果是匿名类呢？看起来任何方式都没法阻止反射调用那些非公共访问权限的方法。对于字段来说 也是这样，即便是 private 字段：

​		但实际上 final 字段在被修改时是安全的。运行时系统会在不抛出异常的情况下 接受任何修改的尝试，但是实际上不会发生任何修改。

​	逆向

​		通常，所有这些违反访问权限的操作并不是什么十恶不赦的。如果有人使用这样的 技术去调用标志为 private 或包访问权限的方法（很明显这些访问权限表示这些人不 应该调用它们），那么对他们来说，如果你修改了这些方法的某些地方，他们不应该抱 怨。另一方面，总是在类中留下后门，也许会帮助你解决某些特定类型的问题（这些问 题往往除此之外，别无它法）。总之，不可否认，反射给我们带来了很多好处。 程序员往往对编程语言提供的访问控制过于自信，甚至认为 Java 在安全性上比其 它提供了（明显）更宽松的访问控制的语言要优越4。然而，正如你所看到的，事实并 不是这样。

