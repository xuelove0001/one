java第十五章异常

Java 的基本理念是 “结构不佳的代码不能运行”。

概述：

​	改进的错误恢复机制是提高代码健壮性的最强有力的方式。因为 Java 的主要 目标之一就是创建供他人使用的程序构件。

​	发现错误的理想时机是在**编译阶段也就是在你试图运行程序之前**。然而，编译期 间并不能找出所有的错误，余**下的问题必须在运行期间解决。**这就需要错误源能通过某 种方式，把适当的信息传递给某个接收者——该接收者将知道如何正确处理这个问题。Java 使用异常来提供一致的错误报告模型，使得构件能够与客户端代码可靠地沟 通问题。

   ==要点：==

1. 要想创建健壮的系统，它的每一个构件都必须是健壮的。
2. 异常往往能降低错误处理代码的复杂度。
3. 理想情况下，只需在一个地方处理错误， 即所谓的异常处理程序中。
4. 你所能做的就是从当前环境跳出，并且把问题提交给上 一级环境。这就是抛出异常时所发生的事情。
5. 在使用 new 创建了异常对象之后，此对象 的引用将传给 throw
6. 另外还能用抛出异常的方式从当前的作 用域退出。
7. 可以简单地把异常处理看成一种不同的返回机制，(仅仅是简单，可以i这样理解)
8. 此外，能够抛出任意类型的 Throwable 对象，它是异常类型的根类
9. 注意，只有匹配的 catch 子句才能得到执行
10. 重抛异常会把异常抛给上一级环境中的异常处理程序，同一个 try 块的后续 catch 子句将被忽略
11. 基本理念是用异常的名称代表发生的问题。
12. 如果必须对传递给方法的每个引用都检查其是否为 null它属于 Java 的标准运行时检测的一部分。
13. 如果对 null 引用进行调用，Java 会自动抛出 NullPointerException 异常，
14. 如果用 法恰当的话，直接向上层抛出的确能简化编程。
15. 异常处理系统就像一个活门（trap door），使你能放弃程序的正常执行序列。

==异常概念==

​		C 以及其他早期语言常常具有多种错误处理模式，这些模式往往建立在约定俗成的 基础之上，而并不属于语言的一部分。通常会返回某个特殊值或者设置某个标志，并且 假定接收者将对这个返回值或标志进行检查，以判定是否发生了错误。：对于构造大型、健壮、可维护的程序而 言，这种错误处理模式已经成为了主要障碍。

==解决的办法==是，用强制规定的形式来消除错误处理过程中随心所欲的因素。这种做 法由来已久

  异常” 这个词有 “我对此感到意外” 的意思。问题出现了，你也许不清楚该如何处 理，但你的确知道不应该置之不理，你要停下来，看看是不是有别人或在别的地方，能 够处理这个问题。只是在当前的环境中还没有足够的信息来解决这个问题，所以就把这 个问题提交到一个更高级别的环境中，在那里将作出正确的决定。

==基本异常==

​		异常情形（exceptional condition）是指阻止当前方法或作用域继续执行的问题。

​			当抛出异常后，有几件事会随之发生。首先，同 Java 中其他对象的创建一样，将 使用 new 在堆上创建异常对象。然后，当前的执行路径（它不能继续下去了）被终止， 并且从当前环境中弹出对异常对象的引用。此时，异常处理机制接管程序，并开始寻找 一个恰当的地方来继续执行程序。这个恰当的地**==方就是异常处理程序，==**

​		举一个抛出异常的简单例子。对于对象引用 t，传给你的时候可能尚未被初始化。 所以在使用这个对象引用调用其方法之前，会先对引用进行检查。可以创建一个代表错 误信息的对象，并且将它从当前环境中 “抛出”，这样就把错误信息传播到了 “更大” 的 环境中。这被称为抛出一个异常看起来像这样：

```java
if(t == null)
throw new NullPointerException();
```

==异常参数==

​		与使用 Java 中的其他对象一样，我们总是用 new 在堆上创建异常对象，这也伴随 着存储空间的分配和构造器的调用。所有标准异常类都有两个构造器：一个是无参构造 器；另一个是接受字符串作为参数，以便能把相关信息放入异常对象的构造器：

```java
throw new NullPointerException("t = null");
```

==异常捕获==

​		要明白异常是如何被捕获的，必须首先理解监控区域（guarded region）的概念。它 是一段可能产生异常的代码，并且后面跟着处理这些异常的代码

==try 语句块==

​		如果在方法内部抛出了异常（或者在方法内部调用的其他方法抛出了异常），这个 方法将在抛出异常的过程中结束。**要是不希望方法就此结束**，可以在方法内**设置一个特 殊的块来捕获异常**。因为在这个块里 “尝试” 各种（可能产生异常的）方法调用，所以 称为 try 块。

```java
try {
// Code that might generate exceptions
}
```

==异常处理程序==   当然，抛出的异常必须在某处得到处理。这个 “地点” 就是异常处理程序

而且针 对每个要捕获的异常，得准备相应的处理程序。异常处理程序紧跟在 try 块之后，以关 键字 catch 表示：

异常处理程序必须紧跟在 try 块之后。当异常被抛出时，异常处理机制将负责搜寻 参数与异常类型相匹配的第一个处理程序。然后进入 catch 子句执行，此时认为异常得到了处理。一旦 catch 子句结束，则处理程序的查找过程结束。		

==终止与恢复==  异常处理理论上有两种基本模型

​		。==Java 支持终止模型==（它是 Java 和 C++ 所支持 的模型）。在这种模型中，将假设错误非常严重，以至于程序无法返回到异常发生的地 方继续执行。一旦异常被抛出，就表明错误已无法挽回，也不能回来继续执行。

​		==另一种称为恢复模型==。意思是异常处理程序的工作是修正错误，然后重新尝试调用 出问题的方法，并认为第二次能成功。如果想要用 Java 实现类似恢复的行为，那么在遇见错误时就不能抛出异常， 而是调用方法来修正该错误。或者，把 try 块放在 while 循环里，这样就不断地进入 try 块，直到得到满意的结果。

==自定义异常==

​		不必拘泥于 Java 已有的异常类型。Java 异常体系不可能预见你将报告的所有错误， 所以你可以创建自己的异常类，来表示你的程序中可能遇到的问题。要自己定义异常类，必须从已有的异常类继承，最好是选择意思相近的异常类继承 （不过这样的异常并不容易找）。建立新的异常类型最简单的方法就是让编译器为你产生 无参构造器

==在异常处理程序中==

​    在异常处理程序中，调用了在 Throwable 类声明（Exception 即从此类继承）的 printStackTrace() 方法。就像从输出中看到的，它将打印 “从方法调用处直到异常抛出 处” 的方法调用序列。这里，信息被发送到了 System.out，并自动地被捕获和显示在输 出中。但是，如果调用默认版本：e.printStackTrace(); 信息就会被输出到标准错误流。

异常与记录日志

​		静态的 Logger.getLogger() 方法创建了一个 String 参数相关联的 Logger 对象（通常 与错误相关的包名和类名）

==异常声明==

​		Java 鼓励人们把方法可能会抛出的异常告知使用此方法的客户端程序员。这是种 优雅的做法，它使得调用者能确切知道写什么样的代码可以捕获所有潜在的异常。Java 提供了相应的 语法（并强制使用这个语法），使你能以礼貌的方式告知客户端程序员某个方法可能会 抛出的异常类型，然后客户端程序员就可以进行相应的处理。这就是异常说明，它属于 方法声明的一部分，紧跟在形式参数列表之后。

​		异常说明使用了附加的关键字 throws，后面接一个所有潜在异常类型的列表，所以 方法定义可能看起来像这样：

```java
void f() throws TooBig, TooSmall, DivZero { // ..
但是，要是这样写：
void f() { // .就表示此方法不会抛出任何异常（除了从 RuntimeException 继承的异常，
```

**不过还是有个能 “作弊” 的地方**：可以声明方法将抛出异常，实际上却不抛出。编 译器相信了这个声明，并强制此方法的用户像真的抛出异常那样使用这个方法。这样做 的好处是，为异常先占个位子，以后就可以抛出这种异常而不用修改已有的代码。在定 义抽象基类和接口时这种能力很重要，这样派生类或接口实现就能够抛出这些预先声明 的异常。 这种在编译时被强制检查的异常称为被检查的异常。

==捕获所有异常==

​		可以只写一个异常处理程序来捕获所有类型的异常,通过捕获异常类型的基类 Exception，就可以做到这一点（事实上还有其他的基类，但 Exception 是所有编程行为相 关的基类）：

```java
catch(Exception e) {
System.out.println("Caught an exception");
}
```

**这将捕获所有异常**，所以最好把它放在处理程序列表的末尾，以防它抢在其他处理 程序之前先把异常捕获了。因为 Exception 是与编程有关的所有异常类的基类，所以它不会含有太多具体的信 息，不过可以调用它从其基类 Throwable 继承的方法String getMessage() String getLocalizedMessage()String toString() 返回对 Throwable 的简单描述，要是有详细信息的话，也会把它包含在内

```java
void printStackTrace()
void printStackTrace(PrintStream)
void printStackTrace(java.io.PrintWriter)
```

打印 Throwable 和 Throwable 的调用栈轨迹。调用栈显示了 “把你带到异常抛出 地点” 的方法调用序列。

```java
Throwable fillInStackTrace()
```

**用于在 Throwable 对象的内部记录栈帧的当前状态**。这在程序重新抛出错误或异 常（很快就会讲到）时很有用。

==多重捕获==

​		如果有一组具有相同基类的异常，你想使用同一方式进行捕获，那你直接 catch 它 们的基类型。但是，如果这些异常没有共同的基类型，在 Java 7 之前，你必须为每一个 类型编写一个 catch：

```java
void x() throws Except1, Except2, Except3, Except4 {}

catch(Except1 | Except2 | Except3 | Except4 e) {
process();
}
catch(Except1 | Except2 e) {
process1();
} catch(Except3 | Except4 e) {
process2();
}
```

==栈轨迹==

​		printStackTrace() 方法所提供的信息可以通过 getStackTrace() 方法来直接访问，这 个方法将返回一个由栈轨迹中的元素所构成的数组，其中每一个元素都表示栈中的一 桢。元素 0 是栈顶元素，并且是调用序列中的最后一个方法调用（这个 Throwable 被 创建和抛出之处）。数组中的最后一个元素和栈底是调用序列中的第一个方法调用。下 面的程序是一个简单的演示示例

==重新抛出异常==

​		有时希望把刚捕获的异常重新抛出，尤其是在使用 Exception 捕获所有异常的时 候。既然已经得到了对当前异常对象的引用，可以直接把它重新抛出

```java
catch(Exception e) {
System.out.println("An exception was thrown");
throw e;
}
```

重抛异常会把异常抛给上一级环境中的异常处理程序，同一个 try 块的后续 catch 子句将被忽略。此外，异常对象的所有信息都得以保持，所以高一级环境中捕获此异常 的处理程序可以从这个异常对象中得到所有信息。

抛出当前异常对象

​		如果只是把当前异常对象重新抛出，那么 printStackTrace() 方法显示的将是原来 异常抛出点的调用栈信息（就是被调用的方法和程序的异常），而并非重新抛出点的信息。要想更新这个信息，可以调用 fillInStackTrace() 方法，这将返回一个 Throwable 对象，它是通过把当前调用栈信息填 入原来那个异常对象而建立的，就像这样

​		有可能在捕获异常之后抛出另一种异常。这么做的话，得到的效果类似于使用 fillInStackTrace()，有关原来异常发生点的信息会丢失，剩下的是与新的抛出点有关的信 息

==精准的重新抛出异常==

​		在 Java 7 之前，如果捕捉到一个异常，重新抛出的异常类型只能与原异常完全相 同。这导致代码不精确，Java 7 修复了这个问题。所以在 Java 7 之前，这无法编译：

==异常链==

​	常常会想要在捕获一个异常后抛出另一个异常，并且希望把原始异常的信息保存下 来，这被称为异常链。在 JDK1.4 以前，程序员必须自己编写代码来保存原始异常的信 息。现在所有 Throwable 的子类在构造器中都可以接受一个 cause（因由）对象作为参数。这个 cause 就用来表示**原始异常**，这样通过把原始异常传递给新的异常，使得即使 在当前位置创建并抛出了新的异常，也能通过这个异常链追踪到异常最初发生的位置。

​		有趣的是，在 Throwable 的子类中，只有三种基本的异常类提供了带 cause 参数 的构造器。它们是 Error（用于 Java 虚拟机报告系统错误）、Exception 以及 RuntimeException。如果要把其他类型的异常链接起来，应该使用 initCause() 方法而不是构造 器。

==Java 标准异常==

​		所以 Java 程序 员关心的基类型通常是 Exception，，Throwable 这个 Java 类被用来表示任何可以作为异常被抛出的类

==特例：RuntimeException==

```java
if(t == null)
throw new NullPointerException();
```

==属于运行时异常的类型有很多==这是继承的一个绝佳例子：建立具有相同特征和行为的一组类型

RuntimeException 代表的是编程错误：

1. 无法预料的错误。比如从你控制范围之外传递进来的 null 引用。
2. 作为程序员，应该在代码中进行检查的错误。（比如对于 ArrayIndexOutOfBoundsException，就得注意一下数组的大小了。）在一个地方发生的异常，常常会在另 一个地方导致错误。
3. RuntimeException 类型的异常也许会穿越所有的执行路径直达 main() 方法，而不会被捕获
4. 如果 RuntimeException 没有被捕获而直达 main()，那么在程序退出前将调用异常 的 printStackTrace() 方法。
5. 是一个特例。对于这种异 常类型，编译器不需要异常说明，其输出被报告给了 System.err
6. 请务必记住：代码中只有 RuntimeException（及其子类）类型的异常可以被忽略， 因为编译器强制要求处理所有受检查类型的异常。

==使用 finally 进行清理==

​		==有一些代码片段，可能会希望无论 try 块中的异常是否抛出，它们都能得到执行。== 这通常适用于内存回收之外的情况（因为回收由垃圾回收器完成），为了达到这个效果， 可以在异常处理程序后面加上 finally 子句。完整的异常处理程序看起来像这样：

==finally 用来做什么？==

​		对于没有垃圾回收和析构函数自动调用机制的语言来说，finally 非常重要。

​		==当要把除内存之外的资源恢复到它们的初始状态时，就要用到 finally 子句。(这种 需要清理的资源包括：已经打开的文件或网络连接，在屏幕上画的图形，甚至可以是外 部世界的某个开关)==

​		当涉及 break 和 continue 语句的时候，finally 子句也会得到执行。请注意，如果把 finally 子句和带标签的 break 及 continue 配合使用，在 Java 里就没必要使用 goto 语 句了

==在 return 中使用 finally== （仍然执行finally）

==缺憾：异常丢失==

​		遗憾的是，Java 的异常实现也有瑕疵。异常作为程序出错的标志，决不应该被忽 略，但它还是有可能被轻易地忽略。用某些特殊的方式使用 finally 子句，就会发生这种 情况：(==某些特殊的方式使用finally 子句 会出错==)

​		一种更加简单的丢失异常的方式是从 finally 子句中返回：

==异常限制==

​		当覆盖方法的时候，只能抛出在基类方法的异常说明里列出的那些异常。这个限制 很有用，因为这意味着与基类一起工作的代码，也能和导出类一起正常工作（这是面向 对象的基本概念），异常也不例外。

异常限制对构造器不起作用。派生类构造器的异常说明必须包含基类构造 器的异常说明。派生类构造器不能捕获基类构造器抛出的异常。在继承中方法异常说明但异常说明本身并不属于方 法类型的一部分，（因此不会继承，在特定方法）

==构造器==

​		有一点很重要，即你要时刻询问自己 “如果异常发生了，所有东西能被正确的清理 吗？” 尽管大多数情况下是非常安全的，但涉及构造器时，问题就出现了。构造器会把 对象设置成安全的初始状态，但还会有别的动作，比如打开一个文件，这样的动作只有 在对象使用完毕并且用户调用了特殊的清理方法之后才能得以清理。如果在构造器内 抛出了异常，这些清理行为也许就不能正常工作了。这意味着在编写构造器时要格外细 心

==解决办法==

​	对于在构造阶段可能会抛出异常，并且要求清理的类，最安全的使用方式是使用嵌 套的 try 子句

​		对 InputFile 对象的构造在其自己的 try 语句块中有效， 如果构造失败，将进入外部的 catch 子句，而 dispose() 方法不会被调用。但是，如果构 造成功，我们肯定想确保对象能够被清理，因此在构造之后立即创建了一个新的 try 语 句块。执行清理的 finally 与内部的 try 语句块相关联。在这种方式中，finally 子句在构 造失败时是不会执行的，而在构造成功时将总是执行。

​	这种通用的清理惯用法在构造器不抛出任何异常时也应该运用，其基本规则是：在 创建需要清理的对象之后，立即进入一个 try-finally 语句块

==Try-With-Resources 用法==

​		幸运的是，Java 7 引入了 try-with-resources 语法，它可以非常清楚地简化上面的 代码：在 Java 7 之前，try 后面总是跟着一个 {，但是现在可以跟一个带括号的定义 — —==这里是我们创建的 FileInputStream 对象。括号内的部分称为资源规范头（resource specification header）。==更重要的是，无 论你如何退出 try 块（正常或通过异常），和以前的 finally 子句等价的代码都会被执行， 并且不用编写那些杂乱而棘手的代码。这是一项重要的改进。

==它是如何工作的？try-with-resources==

​		try-with-resources 定义子句中创建的对象（在括号内）必须实现 java.lang.AutoCloseable 接口，这个接口只有一个方法：close()。当在 Java 7 中引入AutoCloseable 时，许多接口和类被修改以实现它查看 Javadocs 中的 AutoCloseable， 可以找到所有实现该接口的类列表，其中包括 Stream 对象

==特性==

​	[1] 你在这里可以看到其他的特性：资源规范头中可以包含多个定义，并且通过分 号进行分割（最后一个分号是可选的）。规范头中定义的每个对象都会在 try 语句 块运行结束之后调用 close() 方法。

​	• [2] try-with-resources 里面的 try 语句块可以不包含 catch 或者 finally 语句而独立 存在。在这里，IOException 被 main() 方法抛出，所以这里并不需要在 try 后面 跟着一个 catch 语句块。

Java 5 中的 Closeable 已经被修改，修改之后的接口继承了 AutoCloseable 接口。所 以所有实现了 Closeable 接口的对象，都支持了 try-with-resources 特性。

着资源规范头实际上被 try 块包围

==异常匹配==

​		抛出异常的时候，异常处理系统会按照代码的书写顺序找出 “最近” 的处理程序。 找到匹配的处理程序之后，它就认为异常将得到处理，然后就不再继续查找。查找的时候并不要求抛出的异常同处理程序所声明的异常完全匹配。派生类的对 象也可以匹配其基类的处理程序，如果把基类的异常放前面，子类的异常就不会执行，编译器就会报错

==其他可选方式==

1. 异常处理的一个重要原则是 “只有在你知道如何处理的情况下才捕获异常”。
2. 实际 上，异常处理的一个重要目标就是把处理错误的代码同错误发生的地点相分离。
3. 

==把异常传递给控制台==

​		在简单的程序中，不用写多少代码就能保留异常的最简单的方法，就是把它们从 main() 传递到控制台。==注意==，main() 作为一个方法也可以有异常说明，这里异常的类型是 Exception，==它 也是所有 “被检查的异常” 的基类==。

==把 “被检查的异常” 转换为 “不检查的异常”==

​		当编写自己使用的简单程序时，从 main() 中抛出异常是很方便的，但这并不总是 有用。真正的问题是，当在一个普通方法里调用别的方法时发现：“我不知道该如何处 理这个异常，但是不能把它’ 吞掉’ 或者打印一些无用的消息。” 有了异常链，一个简单 的解决办法就出现了。可以通过将一个 “被检查的异常” 传递给 RuntimeException 的 构造器，从而将它包装进 RuntimeException 里

```java
try {
// ... to do something useful
} catch(IDontKnowWhatToDoWithThisCheckedException e) {
throw new RuntimeException(e);
}
```

​		如果想把 “被检查的异常” 这种功能 “屏蔽” 掉的话，这看上去像是一个好办法。不 用 “吞下” 异常，也不必把它放到方法的异常说明里面，而异常链还能保证你不会丢失 任何原始异常的信息。

==异常指南==

​		应该在下列情况下使用异常：

	1. 尽可能使用 try-with-resource。
	1. 在恰当的级别处理问题。（在知道该如何处理的情况下才捕获异常。）
	1. 解决问题并且重新调用产生异常的方法。
	1. 进行少许修补，然后绕过异常发生的地方继续执行。
	1. 用别的数据进行计算，以代替方法预计会返回的值。
	1. 把当前运行环境下能做的事情尽量做完，然后把相同的异常重抛到更高层。
	1. . 把当前运行环境下能做的事情尽量做完，然后把不同的异常抛到更高层。
	1. 终止程序。
	1. 进行简化。（如果你的异常模式使问题变得太复杂，那用起来会非常痛苦也很烦 人。）
	1. 让类库和程序更安全。（这既是在为调试做短期投资，也是在为程序的健壮性做长 期投资。）