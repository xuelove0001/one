第十二章集合

​	如果一个程序只包含固定数量的对象且对象的生命周期都是已知的，那么这 是一个非常简单的程序。

​	这显示了 Java 集合库中的两个主要类型。它们的区别在于集合中的每个 “槽”（slot） 保存的元素个数。默认的打印行为，使用集合提供的 toString() 方法即可生成可读性很好的结果。 ==Collection 打印出的内容用方括号括住==，每个元素由逗号分隔。Map 则==由大括号括住， 每个键和值用等号连接（键在左侧，值在右侧）。==

​	Collection 类型在每个槽中只能保存一个元素。==集合不能保存基本类型， 但自动装箱机制会负责执行基本类型和集合中保存的包装类型之间的双向转换。==

   				1. List ，它以特定的顺序保存一组元素；
   				2. Set ，其中元素不允许重复；
   				3. Queue ，只能在集合一 端插入对象，并从另一端移除对象（队列）
   				4. 

​	Map 在每个槽中存放了两个元素，即键和与之关联的值。（HashMap，TreeMap，LinkedHashMap）

​	Map （也称为关联数组）使用键来查找对象，就像一个简单的数据库。（对于map键只存储一次）

​		这里没有指定（或考虑）Map 的大小，因为它会自动调整大小。此外，Map 还知道如何打印自己，它会显示相关联的键和值。



​	

==泛型和类型安全的集合==：使用泛型来确定集合中存在的类型

==基本概念==

​	Java 集合类库采用 “持有对象”（holding objects）的思想，并将其分为两个不同的 概念，表示为类库的基本接口：

1. 集合（Collection）：一个独立元素的序列，这些元素都服从一条或多条规则。List 必须以插入的顺序保存元素，Set 不能包含重复元素，Queue 按照排队规则来确 定对象产生的顺序（通常与它们被插入的顺序相同）。
2. 映射（Map）：一组成对的 “键值对” 对象，允许使用键来查找值。map 允 许我们使用一个对象来查找另一个对象，它也被称作关联数组（associative array），因为它将对象和其它对象关联在一起；或者称作==字典==（dictionary），

==Collection== 接口概括了序列的概念——一种存放一组对象的方式。

		1. ArrayList 是最基本的序列类型（因为 List 不关心是否存在 重复元素。）
		1. Arrays.asList() 方法接受一个数组或是逗号分隔的元素列表（使用可变参数）， 并将其转换为 List 对象。
		1. 

==添加元素组==

==集合的打印==

​		必须使用 Arrays.toString() 来生成数组的可打印形式。但是打印集合无需任何 帮助。



==List 类型有==： ArrayList  和   LinkedList

==Set 类型==：

1. HashSet（是检索元素的最快方法） 使用散列函数
2. TreeSet（它将按比较结果的升序保存对象） 元素存储在红-黑树数据结构中
3.  LinkedHashSet（它将按比较结果的升序保存对象）也使用了散列

==Map 的三种基本风格==：

​		HashMap ，TreeMap 和 LinkedHashMap：
		1. 键和值保存在 HashMap 中的顺序不是插入顺序，因为 HashMap 实现使用了非 常快速的算法来控制顺序
		1. TreeMap 通过比较结果的升序来保存键，
		1. LinkedHashMap 在保持 HashMap 查找速度的同时按键的插入顺序保存键。

​			

下面介绍List

​			List 承诺将元**素保存在特定的序列中**。List 接口在 Collection 的基础上添加了许 多方法，允许在 List 的中间插入和删除元素。

​			有两种类型的 List ：一种可修改的序列。

​				基本的 ArrayList ，擅长随机访问元素，但在 List 中间插入和删除元素时速度 较慢。

​				LinkedList ，它通过代价较低的在 List 中间进行的插入和删除操作，提供了优 化的顺序访问。LinkedList 对于随机访问来说相对较慢，但它具有比 ArrayList 更大的特征集

迭代器 Iterators

​		==迭代器（也是一种设计模式）的概念实现了这种抽象==。迭代器是一个对象，它在一 个序列中移动并选择该序列中的每个对象，而客户端程序员不知道或不关心该序列的底 层结构。

​		另外，迭代器通常被称为轻量级对象（lightweight object）：创建它的代价小。因此，经常可以看到一些对迭代器有些奇怪的约束。

​		例如，Java 的 Iterator 只能单向 移动。这个 Iterator 只能用来：

		1. 使用 iterator() 方法要求集合返回一个 Iterator。Iterator 将准备好返回序列 中的第一个元素。
		1. 使用 next() 方法获得序列中的下一个元素。
		1. 使用 hasNext() 方法检查序列中是否还有元素。
		1. 使用 remove() 方法将迭代器最近返回的那个元素删除。

==有了 Iterator ，就不必再为集合中元素的数量操心了。这是由 hasNext() 和 next() 关心的事情。==

 ==如果只是想向前遍历 List ，并不打算修改 List 对象本身，那么使用 for-in 语法更 加简洁。==							

**ListIterator ListIterator** 是一个更强大的 Iterator 子类型，它只能由各种 List 类生成。Iterator 只能向前移动，而 ListIterator 可以双向移动。它可以生成迭代器在列表中指向 位置的后一个和前一个元素的索引，并且可以使用 set() 方法替换它访问过的最近一 个元素。可以通过调用 listIterator() 方法来生成指向 List 开头处的 ListIterator ， 还可以通过调用 listIterator(n) 创建一个一开始就指向列表索引号为 n 的元素处的 ListIterator 。

==for-in 和迭代器==

​		到目前为止，for-in 语法主要用于数组，但它也适用于任何 Collection 对象。实 际上在使用 ArrayList 时

​		由于 cs 是一个 Collection ，因此该代码展示了使用 for-in 是所有 Collection 对 象的特征。 这样做的原因是 Java 5 引入了一个名为 Iterable 的接口，该接口包含一个能够生 成 Iterator 的 iterator() 方法。==for-in 使用此 Iterable 接口来遍历序列。因此，如 果创建了任何实现了 Iterable 的类，都可以将它用于 for-in 语句中==：

==适配器方法惯用法==（内部类）

​		如果现在有一个 Iterable 类，你想要添加一种或多种在 for-in 语句中使用这个类 的方法，应该怎么做呢？例如，你希望可以选择正向还是反向遍历一个单词列表。如果 直接继承这个类，并重写 iterator() 方法，则只能替换现有的方法，而不能实现遍历 顺序的选择。 一种解决方案是所谓适配器方法（Adapter Method）的惯用法。“适配器” 部分来 自于设计模式，因为必须要提供特定的接口来满足 for-in 语句。如果已经有一个接口并 且需要另一个接口时，则编写适配器就可以解决这个问题。在这里，若希望在默认的向迭代器的基础上，添加产生反向迭代器的能力，因此不能使用重写，相反，而是添加 了一个能够生成 Iterable 对象的方法，该对象可以用于 for-in 语句。这使得我们可以 提供多种使用 for-in 语句的方式
