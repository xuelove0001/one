第十八章字符串

​		1. 字符串操作毫无疑问是计算机程序设计中最常见的行为之一。在 Java 大展拳脚的 Web 系统中更是如此。在本章中，我们将深入学习在 Java 语 言中应用最广泛的 String 类，并研究与之相关的类及工具。

字符串的不可变：

​		String 对象是不可变的。查看 JDK 文档你就会发现，String 类中每一个看起来 会修改 String 值的方法，实际上都是创建了一个全新的 String 对象，以包含修改后 的字符串内容。而最初的 String 对象则丝毫未动。

字符串的工作原理：

   当把 q 传递给 upcase() 方法时，实际传递的是引用的一个拷贝。其实，每当把 String 对象作为方法的参数时，都会复制一份引用，而该引用所指向的对象其实一直待 在单一的物理位置上，从未动过。

​    对于一个方法而言，参数是为该方 法提供信息的，而不是想让该方法改变自己的。

==\+ 的重载与 StringBuilder==

​		String 对象是不可变的，你可以给一个 String 对象添加任意多的别名。因为 String 是只读的，所以指向它的任何引用都不可能修改它的值，因此，也就不会影响 到其他引用。

​		==不可变性会带来一定的效率问题。操作符 + 可以用来连接 String：==

​		不可变性会带来一定的效率问题。为 String 对象重载的 + 操作符就是一个例子。 重载的意思是，一个操作符在用于特定的类时，被赋予了特殊的意义（用于 String 的 + 与 += 是 Java 中仅有的两个重载过的操作符，Java 不允许程序员重载任何其他的操 作符 1）。(+ 重载会创建StringBuilder)

使用   ==+==  报错 ==递归调用==
		这里发生了自动类型转换，由 InfiniteRecursion 类型转换为 String 类型。因为 编译器发现一个 String 对象后面跟着一个 “+”，而 “+” 后面的对象不是 String，于 是编译器试着将 this 转换成一个 String。它怎么转换呢？正是通过调用 this 上的 toString() 方法，于是就发生了递归调用。

​	解决： 如果你真的想要打印对象的内存地址，应该调用 Object.toString() 方法，这才 是负责此任务的方法。所以，不要使用 this，而是应该调用 super.toString() 方法。

  ==帮助理解==

​		可以想象一下，这段代码是这样工作的：String 可能有一个 append() 方法，它会 生成一个新的 String 对象，以包含 “abc” 与 mango 连接后的字符串。该对象会再创建 另一个新的 String 对象，然后与 “def” 相连，生成另一个新的对象，

==StringBuilder==

依此类推。虽然源代码中并没有 使用 StringBuilder 类，但是编译器却自作主张地使用了它，就因为它更高效。注意：StringBuilder 是在循环内构造的，这意味着每进行一 次循环，会创建一个新的 StringBuilder 对象。可 以 看 到， 不 仅 循 环 部 分 的 代 码 更 简 短、 更 简 单， 而 且 它 只 生 成 了 一 个 StringBuilder 对象。显式地创建 StringBuilder 还允许你预先为其指定大小。 如果你已经知道最终字符串的大概长度，那预先指定 StringBuilder 的大小可以避免 频繁地重新分配缓冲。

==意外递归==

​		Java 中的每个类从根本上都是继承自 Object，标准集合类也是如此，它们都有 toString() 方法，并且覆盖了该方法，使得它生成的 String 结果能够表达集合自身， 以及集合包含的对象。例如 ArrayList.toString()，它会遍历ArrayList中包含的所有有对象。调用每个元素上的toString()方法

==字符串操作==

​		从这个表可以看出，当需要改变字符串的内容时，String 类的方法都会返回一个 新的 String 对象。同时，如果内容不改变，String 方法只是返回原始对象的一个引用 而已。这可以节约存储空间以及避免额外的开销。

==格式化输出==

​		Java SE5 终于推出了 C 语言中 printf() 风格的格式化输出 这一功能。加上要插入其中的值，然后将其格式化输 出。printf() 并不使用重载的 + 操作符（C 语言没有重载）来连接引号内的字符串或 字符串变量，而是使用特殊的占位符来表示数据将来的位置。而且它还将插入格式化字 符串的参数，以逗号分隔，排成一行。

```java
System.out.printf("Row 1: [%d %f]%n", x, y);
```

​		这一行代码在运行的时候，首先将 x 的值插入到 %d_ 的位置，然后将 y 的值插入 到 %f 的位置。这些占位符叫做格式修饰符，==Java SE5 引入了 format()== 方法，可用于 PrintStream 或者 PrintWriter 对象

​		可以看到，==format() 和 printf() 是等价的==，它们只需要一个简单的格式化字符 串，加上一串参数即可，每个参数对应一个格式修饰符。 String 类也有一个 static format() 方法，可以格式化字符串。

==Formatter 类==

​		在 Java 中，所有的格式化功能都是由 java.util.Formatter 类处理的。可以将 Formatter 看做一个翻译器，它将你的格式化字符串与数据翻译成需要的结果。当你创 建一个 Formatter 对象时，需要向其构造器传递一些信息，告诉它最终的结果将向哪 里输出格式化修饰符 %s 表明这里需要 String 参数。

格式化修饰符在插入数据时，如果想要优化空格与对齐，你需要更 精细复杂的格式修饰符。以下是其通用语法：%[argument_index$][flags][width][.precision]conversion程序中的每个变量都用到了 b 转换。虽然它对各种类型都是合法的，但其行 为却不一定与你想象的一致程序中的每个变量都用到了 b 转换。虽然它对各种类型都是合法的，但其行 为却不一定与你想象的一致 ==注意==  将b应用于非布尔类型的对象时请格外小心。

==正则表达式==

​		很久之前，正则表达式就已经整合到标准 Unix 工具集之中，例如 sed、awk 和程 序语言之中了，在 Java 中，字符串操作还主要集中于 String、StringBuffer 和 StringTokenizer 类。与正则表达式相比较，它们只能提供相当简单的功能。

  1. 如果你想表示一位数字，那么正则表达式应该是 \\\d

  2. 而在 Java 中，\\ \的意思是 “我要 插入一个正则表达式的反斜线，所以其后的字符具有特殊的意义。

  3. 如果你想插入一个普通的反斜线，应该这样 写 \\\\

  4. 不过换行符和制表符之类的东西只需要使用单反斜线：\n\t。

  5. 要找一个数字，它可能有一个负号在最前面，那 你就写一个负号加上一个问号，就像这样：-?

  6. 要表示 “==一个或多个之前的表达式==”，应该使用 +。所以，如果要表示 “可能有一个 负号，后面跟着一位或多位数字”，可以这样：

     ```java
     -?\\d+
     ```

  7. 应用正则表达式最简单的途径，就是利用 String 类内建的功能。例如，你可以检 查一个 String 是否匹配如上所述的正则表达式：

  8. 在正则表达式中，用括号将表达式进行分组，用 竖线 | 表示或操作。也就是：(==竖线分割表示 “或”==)

     ```java
     (-|\\+)?
     ```

  9. 这个正则表达式表示字符串的起始字符可能是一个 - 或 +，或者二者都没有（因为 后面跟着 ? 修饰符）。

  10. 因为字符 + 在正则表达式中有特殊的意义，所以必须使用 \\ 将 其转义，使之成为表达式中的一个普通字符。

  11. String 类还自带了一个非常有用的正则表达式工具——split() 方法，其功能是 “将字符串从正则表达式匹配的地方切开。

  12. 普通的字符作为正则表达式

  13.  \\\W，它的意思是一个非单词字符（如果 W 小 写，\\w，则表示一个单词字符）

  14. f\\\w+ 第一个表达式要匹配的是，以字母 f 开头，后面跟一个或多个字母（注意这里的 w 是小写的）。

      ```java
      表达式 含义
      B 指定字符 B
      \xhh 十六进制值为 0xhh 的字符
      \uhhhh 十六进制表现为 0xhhhh 的 Unicode 字符
      \t 制表符 Tab
      \n 换行符
      \r 回车
      \f 换页
      \e 转义（Escape）
      ```

      当你学会了使用字符类（character classes）之后，正则表达式的威力才能真正显现 出来。以下是一些创建字符类的典型方式，以及一些预定义的类：

      ```java
      表达式 含义
      . 任意字符
      [abc] 包含 a、b 或 c 的任何字符（和 a\|b\|c 作用相同）
      [ˆabc] 除 a、b 和 c 之外的任何字符（否定）
      [a-zA-Z] 从 a 到 z 或从 A 到 Z 的任何字符（范围）
      [abc[hij]] a、b、c、h、i、j 中的任意字符（与 a\|b\|c\|h\|i\|j 作用相同）（合并）
      [a-z&&[hij]] 任意 h、i 或 j（交）
      \s 空白符（空格、tab、换行、换页、回车）
      \S 非空白符（[ˆ\s]）
      \d 数字（[0-9]）
      \D 非数字（[ˆ0-9]）
      \w 词字符（[a-zA-Z_0-9]）
      \W 非词字符（[ˆ\w]）
      ```

  15. 贪婪型：量词总是贪婪的，除非有其他的选项被设置。贪婪表达式会为所有可能 的模式发现尽可能多的匹配。导致此问题的一个典型理由就是假定我们的模式仅能匹配第一个可能的字符组，如果它是贪婪的，那么它就会继续往下匹配。

  16. • 勉强型：用问号来指定，这个量词匹配满足模式所需的最少字符数。因此也被称 作懒惰的、最少匹配的、非贪婪的或不贪婪的。

  17. ```java
      贪婪型 勉强型 占有型 如何匹配
      X? X?? X?+ 一个或零个 X
      X* X*? X*+ 零个或多个 X
      X+ X+? X++ 一个或多个 X
      X{n} X{n}? X{n}+ 恰好 n 次 X
      X{n,} X{n,}? X{n,}+ 至少 n 次 X
      X{n,m} X{n,m}? X{n,m}+ X 至少 n 次，但不超过 m 次
      ```

  18. abc+ 看起来它似乎应该匹配 1 个或多个 abc 序列，如果我们把它应用于输入字符串 abcabcabc，则实际上会获得 3 个匹配。然而，这个表达式实际上表示的是：匹配 ab， 后面跟随 1 个或多个 c。要表明匹配 1 个或多个完整的字符串 abc，我们必须这样表 示： (abc)+

  19. 只需导入 java.util.regex 包，然后用 static Pattern.compile() 方法来编译你的正则表达式即可。它会根据你的 String 类型的 正则表达式生成一个 Pattern 对象。接下来，把你想要检索的字符串传入 Pattern 对 象的 matcher() 方法。matcher() 方法会生成一个 Matcher 对象，它有很多功能可用 （可以参考 java.util.regext.Matcher 的 JDK 文档）。

  20. 

==扫描输入==

​		到目前为止，从文件或标准输入读取数据还是一件相当痛苦的事情。一般的解决办 法就是读入一行文本，对其进行分词，然后使用 Integer、Double 等类的各种解析方 法来解析数据：

​		终于，Java SE5 新增了 Scanner 类，它可以大大减轻扫描输入的工作负担：Scanner 的构造器可以接收任意类型的输入对象，包括 File、InputStream、String 或者像此例中的 Readable 实现类。有了 Scanner，所有的输入、分词、以及解析的操作都隐藏在不同类型的 next 方 法中。普通的 next() 方法返回下一个 String。

​		所有的基本类型（除 char 之外）都有 对应的 next 方法，包括 BigDecimal 和 BigInteger。所有的 next 方法，只有在找到 一个完整的分词之后才会返回。Scanner 还有相应的 hasNext 方法，用以判断下一个输 入分词是否是所需的类型，如果是则返回 true。