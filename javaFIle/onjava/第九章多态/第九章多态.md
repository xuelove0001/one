第九章多态 

​    多态是面向对象编程语言中，继数据抽象和继承之外的第三个重要特性。

​     多态提供了另一个维度的接口与实现分离，以解耦做什么和怎么做。多态不仅能改 善代码的组织，提高代码的可读性，而且能创建有扩展性的程序——无论在最初创建项 目时还是在添加新特性时都可以 “生长” 的程序。

​	封装通过合并特征和行为来创建新的数据类型。

**为什么要向上转型**：

​     缺点：必须为添加的每个新 Instrument 类（就是实现的新类）编写特定 的方法。这意味着开始时就需要更多的编程，而且以后如果添加类似 tune() 的新方法。或 Instrument 的新类型时，还有大量的工作要做。考虑到如果你忘记重载某个方法， 编译器也不会提示你，这会造成类型的整个处理过程变得难以管理。

   ==缺点：==

==虽然这是一种有用且明智的方法（依赖具体情况），但是也存在缺点。派生类中接 口的扩展部分在基类中不存在（不能通过基类访问到这些扩展接口），因此一旦向上转 型，就不能通过基类调用这些新方法：==

==解决办法：能够访问该类型中的扩展方法==

==向下转型与运行时类型信息==

​		(**描述**)向上转型永远是安全的，因为基类不会具有比派生类更多的接口。因此，每条发送 给基类接口的消息都能被接收。但是对于向下转型，你无法知道一个形状是圆，它有可 能是三角形、正方形或其他一些类型。

​		在某些语言中（如 C++），必须执行一个特殊的操作来获得安全的向下转型，==但是 在 Java 中，每次转型都会被检查！所以即使只是进行一次普通的加括号形式的类型转 换，在运行时这个转换仍会被检查，以确保它的确是希望的那种类型。如果不是，就会 得到 ClassCastException （类转型异常）。==这种在运行时检查类型的行为称作运行时类 型信息。

   **改进**：
		如果只写一个方法以基类作为参数，而不用管是哪个具体派生类，这样会变得更好 吗？也就是说，如果忘掉派生类，编写的代码只与基类打交道，会不会更好呢？ 这正是多态所允许的。但是大部分拥有面向过程编程背景的程序员会对多态的运 作方式感到一些困惑。

==研究主题：基类引用怎么指向实现的具体类==

​		它接受一个 Instrument 引用。那么编译器是如何知道这里的 Instrument 引用 指向的是 Wind，而不是 Brass 或 Stringed 呢？编译器无法得知。为了深入理解这个 问题，有必要研究一下绑定这个主题。

​		**方法调用绑定**：

​			将一个方法调用和一个方法主体关联起来称作绑定。若绑定发生在程序运行前（如 果有的话，由编译器和链接器实现），叫做==前期绑定==。

上述程序让人困惑的地方就在于前期绑定，因为编译器只知道一个 Instrument 引 用，它无法得知究竟会调用哪个方法。

​		解决方法就是后期绑定，意味着在运行时根据对象的类型进行绑定。==后期绑定==也称 为动态绑定或运行时绑定。从而调用恰当的方法。也就是说，编译器仍然不知道对象的类型， 但是方法调用机制能找到正确的方法体并调用。每种语言的后期绑定机制都不同，但是 可以想到，对象中一定存在某种类型信息。（可以参照jvm.动态分派）

多态是如何实现的：

一旦当你知道 Java 中所有方法都是通过后期绑定来实现多态时，

==注意：== 记住  属性是不能多态，它们各自被分配了不同的存储空间

“重写” 私有方法 、属性与静态方法、

一旦学会了多态，就可以以多态的思维方式考虑每件事。然而，只有普通的方法调 用可以是多态的。

==构造器和多态：==

通常，构造器不同于其他类型的方法。在涉及多态时也是如此。尽管构造器不具有 多态性（事实上人们会把它看作是隐式声明的静态方法），但是理解构造器在复杂层次 结构中运作多态还是非常重要的。理解这个可以帮助你避免一些不愉快的困扰。

在 “初始化和清理” 和 “复用” 两章中已经简单地介绍过构造器的调用顺序，但那 时还没有介绍多态。 ==在派生类的构造过程中总会调用基类的构造器。初始化会自动按继承层次结构上 移，因此每个基类的构造器都会被调用到==。这么做是有意义的，因为构造器有着特殊的 任务：检查对象是否被正确地构造。由于属性通常声明为 private，你必须假定派生类 只能访问自己的成员而不能访问基类的成员。只有基类的构造器拥有恰当的知识和权限 来初始化自身的元素。因此，必须得调用所有构造器；否则就不能构造完整的对象。这 就是为什么编译器会强制调用每个派生类中的构造器的原因。如果在派生类的构造器 主体中没有显式地调用基类构造器，编译器就会默默地调用无参构造器。如果没有无参 构造器，编译器就会报错（当类中不含构造器时，编译器会自动合成一个无参构造器）。 下面的例子展示了组合、继承和多态在构建顺序上的作用：

​		加载器加载顺序：

​		从创建 Sandwich 对象的输出中可以看出对象的构造器调用顺序如下： 

​			基类构造器被调用。这个步骤被递归地重复，这样一来类层次的顶级父类会被最 先构造，然后是它的派生类，以此类推，直到最底层的派生类。 

​			按声明顺序初始化成员。

​			调用派生类构造器的方法体。 

构造器的调用顺序很重要。当使用继承时，就已经知道了基类的一切，并可以访问 基类中任意 public 和 protected 的成员。

在一个标准方法中，构造动作已经发生过，对象其他部分的所有成员都 已经创建好。

==继承的垃圾回收==

继承和清理 在使用组合和继承创建新类时，大部分时候你无需关心清理。子对象通常会留给垃 圾收集器处理。如果你存在清理问题，那么必须用心地为新类创建一个 dispose() 方 法（这里用的是我选择的名称，你可以使用更好的名称）。由于继承，如果有其他特殊 的清理工作的话，就必须在派生类中重写 dispose() 方法。当重写 dispose() 方法时， 记得调用基类的 dispose() 方法，否则基类的清理工作不会发生：

层级结构中的每个类都有 Characteristic 和 Description 两个类型的成员对象， 它们必须得被销毁。==销毁的顺序应该与初始化的顺序相反，以防一个对象依赖另一个对 象。对于属性来说，就意味着与声明的顺序相反（因为属性是按照声明顺序初始化的）。== 对于基类（遵循 C++ 析构函数的形式），首先进行派生类的清理工作，然后才是基类 的清理。这是因为派生类的清理可能调用基类的一些方法，所以基类组件这时得存活， 不能过早地被销毁。输出显示了，Frog 对象的所有部分都是按照创建的逆序销毁的。 尽管通常不必进行清理工作，但万一需要时，就得谨慎小心地执行。 ==Frog 对象拥有自己的成员对象，它创建了这些成员对象，并且知道它们能存活多 久，所以它知道何时调用 dispose() 方法。==然而，一旦某个成员对象被其它一个或多个 对象共享时，问题就变得复杂了，不能只是简单地调用 dispose()。这里，也许就必须 使用引用计数来跟踪仍然访问着共享对象的对象数量，如下：

**==构造器内部多态方法的行为==**

​		==遇到困境==：如果在构造器中调用了正在构造的对象 的动态绑定方法，会发生什么呢？

​		从概念上讲，构造器的工作就是创建对象（这并非是平常的工作）。在构造器内部， 整个对象可能只是部分形成——只知道基类对象已经初始化。如果构造器只是构造对象 过程中的一个步骤，且构造的对象所属的类是从构造器所属的类派生出的，那么派生部 分在当前构造器被调用时还没有初始化。然而，一个动态绑定的方法调用向外深入到继 承层次结构中，它可以调用派生类的方法。如果你在构造器中这么做，就可能调用一个 方法，该方法操纵的成员可能还没有初始化——这肯定会带来灾难。

​		这么做有个优点：所有事物至少初始化为 0（或某些特殊数据类型与 0 等价的值）， 而不是仅仅留作垃圾。这包括了通过组合嵌入类中的对象引用，被赋予 null。如果忘记 初始化该引用，就会在运行时出现异常。观察输出结果，就会发现所有事物都是 0。 另一方面，应该震惊于输出结果。逻辑方面我们已经做得非常完美，然而行为仍不 可思议的错了，编译器也没有报错（C++ 在这种情况下会产生更加合理的行为）。像这 样的 bug 很容易被忽略，需要花很长时间才能发现。 因此，编==写构造器有一条良好规范：做尽量少的事让对象进入良好状态。如果有可 能的话，尽量不要调用类中的任何方法。在基类的构造器中能安全调用的只有基类的 final 方法（这也适用于可被看作是 final 的 private 方法）。这些方法不能被重写，因 此不会产生意想不到的结果。你可能无法永远遵循这条规范，但应该朝着它努力。==

==协变返回类型==

Java 5 中引入了协变返回类型，这表示派生类的被重写方法可以返回基类方法返 回类型的派生类型：

使用继承设计：

​		学习过多态之后，一切看似都可以被继承，因为多态是如此巧妙的工具。这会给设 计带来负担。事实上，如果利用==已有类创建新类首先选择继承的话，事情会变得莫名的 复杂==。

​	更好的方法是首先选择组合，特别是不知道该使用哪种方法时。组合不会强制设计 是继承层次结构，而且组合更加灵活，因为可以动态地选择类型（因而选择相应的行 为），而继承要求必须在编译时知道确切类型。	