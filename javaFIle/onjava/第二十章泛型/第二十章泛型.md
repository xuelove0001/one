==第二十章泛型==

​		普通的类和方法只能使用特定的类型：基本数据类型或类类型。如果编写的 代码需要应用于多种类型，这种严苛的限制对代码的束缚就会很大。

​		==即便是接口也还是有诸多限制。一旦指定了接口，它就要求你的代码必须使用特定 的接口。而我们希望编写更通用的代码，能够适用 “非特定的类型”，而不是一个具体的 接口或类。这就是泛型的概念，是 Java 5 的重大变化之一。这就是 Java 泛型的核心概念：你只需告诉编译器要使用什么类型，剩下的细节交 给它来处理。==

​		泛型实现了参数化类型，这样你 编写的组件（通常是集合）可以适用于多种类型。

==初衷==

“泛型” 这个术语的含义是 “适用于 很多类型”。编程语言中泛型出现的初衷是通过解耦类或方法与所使用的类型之间的约 束，使得类或方法具备最宽泛的表达力。随后你会发现 Java 中泛型的实现并没有那么 “泛”，你可能会质疑 “泛型” 这个词是否合适用来描述这一功能。

==简单泛型==

​		促成泛型出现的最主要的动机之一是为了创建集合类，参见 集合 章节。集合用于 存放要使用到的对象。数组也是如此，不过集合比数组更加灵活，功能更丰富。几乎所 有程序在运行过程中都会涉及到一组对象，因此集合是可复用性最高的类库之一。在 Java 5 之前，我们可以让这个类直接持有 Object 类型的对象泛型的主要目的之一就是用来约定集合要存储什么类型的对象， 并且通过编译器确保规约得以满足。需要使用类型参数，用尖括号括住，放在类名后面。

==发展历史==

​		你可能注意到 h3 的定义非常繁复。在 = 左边有 GenericHolder, 右 边又重复了一次。在 Java 5 中，这种写法被解释成 “必要的”，但在 Java 7 中设计者修 正了这个问题（新的简写语法随后成为备受欢迎的特性）。

泛型的特性及使用：

1. 泛型只不过是一种类型罢了
2. 泛型也可以应用于接口。
3. 作为容器的另一个例子，假设我们需要一个持有特定类型对象的列表
4. 这个例子引出了 Java 泛型的一个局限性：基本类型无法作为类型参数。不过 Java 5 具备自动装箱和拆箱的功能
5. 类本 身可能是泛型的，也可能不是，不过这与它的方法是否是泛型的并没有什么关系。（泛型方法独立于类而改变方法。）
6. 如果方法是 static 的，则无法访问该类的泛型类型参数
7. 要定义泛型方法，请将泛型参数列表放置在返回值之前
8. 泛型方法和变长参数列表可以很好地共存：public static  List makeList(T... args) {}
9. 泛型的一个重要好处是能够简单安全地创建复杂模型。
10. 在泛型代码内部，无法获取任何有关泛型参数类型的信息。
11. 边界  声明 T 必须是 HasF 类型或其子类。
12. 泛型只有在类型参数比某个具体类型（以及其子类）更加 “泛化”——代码能跨多个类工作时才有用。
12. 记住： “边界就是动作发生的地方”。
12. 由于擦除，数组的运行时类型只能是 Object[] 。
12. 因此，无法破坏基础数组的类型，该基础数组只 能是 Object[] 。

==一个元组类库==

​		有时一个方法需要能返回多个对象。而 return 语句只能返回单个对象，解决方法 就是创建一个对象，用它打包想要返回的多个对象。当然，可以在每次需要的时候，专 门创建一个类来完成这样的工作。但是有了泛型，我们就可以一劳永逸。同时，还获得 了编译时的类型安全。**这个概念称为元组，它是将一组对象直接打包存储于单一对象中。可以从该对象读 取其中的元素，但不允许向其中存储新对象（这个概念也称为 数据传输对象或 信使）。**

​	==通常，元组可以具有任意长度，元组中的对象可以是不同类型的不过，我们希望 能够为每个对象指明类型，并且从元组中读取出来时，能够得到正确的类型。构造函数传入要存储的对象。这个元组隐式地保持了其中元素的次序。元组的使用程序可以读取 a1 和 a2 然后对它们执行任 何操作，但无法对 a1 和 a2 重新赋值。==

​		有了泛型，你可以很容易地创建元组，令其返回一组任意类型的对象。final 声明确实可以确保 public 字段在对象被构造出来之后就不能重新赋值了。

==一个堆栈类==

​	接下来我们看一个稍微复杂一点的例子：堆栈。

==RandomList==

​		作为容器的另一个例子，假设我们需要一个持有特定类型对象的列表，每次调用它 的 select() 方法时都随机返回一个元素。如果希望这种列表可以适用于各种类型，就 需要使用泛型

==泛型接口==

​		泛型也可以应用于接口。

==泛型方法==

​		类本 身可能是泛型的，也可能不是，不过这与它的方法是否是泛型的并没有什么关系。泛型方法独立于类而改变方法。作为准则，请 “尽可能” 使用泛型方法。通常将单 个方法泛型化要比将整个类泛型化更清晰易懂。如果方法是 static 的，则无法访问该类的泛型类型参数，因此，如果使用了泛型 类型参数，则它必须是泛型方法。

​		尽管可以同时对类及其方法进行参数化只有方法 f() 具有类型参数，该参数由方法返回类型之前的参数列表指示。

使用泛型方法时，通常不需要指 定参数类型，因为编译器会找出这些类型。这称为 类型参数推断对于泛型类，必须在实例化该**类时指定类型参数**如果使用基本类型调用 f() ，自动装箱就开始起作用，自动将基本类型包装在它们 对应的包装类型中。

==变长参数和泛型方法==

​		泛型方法和变长参数列表可以很好地共存：

==一个泛型的 Supplier==这是一个**为任意具有无参构造方法的类生成 Supplier 的类**。为了减少键入，它还 包括一个用于生成 BasicSupplier 的泛型方法

​		此类提供了产生以下对象的基本实现：

		1.  是 public 的。因为 BasicSupplier 在单独的包中，所以相关的类必须具有 public 权限，而不仅仅是包级访问权限。
		1.  具有无参构造方法。要创建一个这样的 BasicSupplier 对象，请调用 create() 方法，并将要生成类型的类型令牌传递给它。通用的 create() 方法提供了 BasicSupplier.create(MyType.class) 这种较简洁的语法来代替较笨拙的 new BasicSupplier (MyType.class)。
		1.  泛型方法减少了产生 Supplier 对象所需的代码量    Java 泛型强制传递 Class 对 象，以便在 create() 方法中将其用于类型推断。
		1.  

==简化元组的使用==

​		使用类型参数推断和静态导入，我们将把早期的元组重写为更通用的库。在这里， 我们使用重载的静态方法创建元组：编译器不会在这里警告 f2() ，因为返回值未以参数化方式使用。从某种意义上 说，它被 “向上转型” 为一个未参数化的 Tuple2 。但是，如果尝试将 f2() 的结果放入 到参数化的 Tuple2 中，则编译器将发出警告。

==一个 Set 工具==对于泛型方法的另一个示例，请考虑由 Set 表示的数学关系。这些被方便地定义 为可用于所有不同类型的泛型方法：

==构建复杂模型==

​		泛型的一个重要好处是能够简单安全地创建复杂模型。这将产生一个功能强大的数据结构，而无需太多代码。

==泛型擦除==    Java 泛型是使用擦除实现的。这意味着当你在使用泛型时，任何具体的类型信息都 被擦除了，你唯一知道的就是你在使用一个对象。（它们都被擦除成原生类型 List。）

​		当你开始更深入地钻研泛型时，会发现有大量的东西初看起来是没有意义的。例 如，尽管可以说 ArrayList.class，但不能说成 ArrayList.class

​		Class.getTypeParameters() “返回一个 TypeVariable 对象数 组，表示泛型声明中声明的类型参数…” 这暗示你可以发现这些参数类型。你只能看到用作参数占位符的标识符，这并非有用的信息。

​		因为擦除（==所以会回到原始类型，如果原始类型无限大，就需要继承来限定边界==），Java 编译器无法将 manipulate() 方法必须能调用 obj 的 f() 方法这一 需求映射到 HasF 具有 f() 方法这个事实上。为了调用 f()，我们必须协助泛型类，给定 泛型类一个边界，以此告诉编译器只能接受遵循这个边界的类型。这里重用了 extends 关键字。由于有了边界，下  ==边界  声明 T 必须是 HasF 类型或其子类。==

​		我们说泛型类型参数会擦除到它的第一个边界（可能有多个边界，稍后你将看到）。 我们还提到了类型参数的擦除。编译器实际上会把类型参数替换为它的擦除，就像上面 的示例，T 擦除到了 HasF，就像在类的声明中用 HasF 替换了 T 一样。

​		==这提出了很重要的一点：泛型只有在类型参数比某个具体类型（以及其子类）更加 “泛化”——代码能跨多个类工作时才有用。==

==迁移兼容性==擦除的核心动机是你可以在泛化的客户端上使用非泛型的类库，反之亦然。这经常 被称为 “迁移兼容性”。因此 Java 泛型不仅必须支持向后兼容性

​		本章稍后你会看到，擦除减少了泛型的泛化性。泛型在 Java 中仍然 是有用的，只是不如它们本来设想的那么有用，而原因就是擦除。

==擦除的执行原理：==

​		在基于擦除的实现中，泛型类型被当作第二类类型处理，即不能在某些重要的上下 文使用泛型类型。泛型类型只有在静态类型检测期间才出现，在此之后，程序中的所有 泛型类型都将被擦除，替换为它们的非泛型上界。例如，List 这样的类型注解会被 擦除为 List，普通的类型变量在未指定边界的情况下会被擦除为 Object。

==擦除的问题==

​		擦除主要的正当理由是从非泛化代码到泛化代码的转变过程，以及在不破坏 现有类库的情况下将泛型融入到语言中。擦除允许你继续使用现有的非泛型客户端代 码，直至客户端准备好用泛型重写这些代码。这是一个崇高的动机，因为它不会骤然破 坏所有现有的代码。

​		擦除的代价是显著的。泛型不能用于显式地引用运行时类型的操作中，例如转型、 instanceof 操作和 new 表达式。因为所有关于参数的类型信息都丢失了，当你在编写 泛型代码时，必须时刻提醒自己，你只是看起来拥有有关参数的类型信息而已。

==边界处的动作==

​		因为擦除，我发现了泛型最令人困惑的方面是可以表示没有任何意义的事物。即使 kind 被存储为 Class<T>、擦除也意味着它实际被存储为没有任何参数的 Class。所以它不会产生具体的结果，因而必须转型，这会产生一 条令你无法满意的警告。

​		即使编译器无法得知 add() 中的 T 的任何信息，但它仍可以在编译期确保你放入 FilledList 中的对象是 T 类型。因此，即使擦除移除了方法或类中的实际类型的信息， 编译器仍可以确保方法或类中使用的类型的内部一致性。

​		因为擦除移除了方法体中的类型信息，所以在运行时的问题就是边界：即对象进入 和离开方法的地点。这些正是编译器在编译期执行类型检查并插入转型代码的地点。

		1. ==这就告诉我们泛型的所有动作都发生在边 界处——对入参的编译器检查和对返回值的转型。==
		1. 

==补偿擦除==

​		==因为擦除，我们将失去执行泛型代码中某些操作的能力。无法在运行时知道确切类型==

​		有时，我们可以对这些问题进行编程，但是有时必须通过**引入类型标签来补偿擦 除**。这意味着为所需的类型显式传递一个 Class 对象，以在类型表达式中使用它。类型标签可以使用动态 isInstance() ：

编译器来保证类型标签与泛型参数相匹配。

==创建类型的实例==

​		试图在 Erased.java 中 new T() 是行不通的，部分原因是由于擦除，部分原因是 编译器无法验证 T 是否具有默认（无参）构造函数。

​		Java 中的解决方案是传入一个工厂对象，并使用该对象创建新实例。方便的工厂 对象只是 Class 对象，因此，如果使用类型标记，则可以使用 newInstance() 创建该 类型的新对象

​		这样可以编译，但对于 ClassAsFactory 会失败，这是因为 Integer 没 有无参构造函数。由于错误不是在编译时捕获的，因此语言创建者不赞成这种方法。他们建议使用显式工厂（Supplier）并约束类型，以便只有实现该工厂的类可以这样创建 对象。这是创建工厂的两种不同方法

​		GenericWithCreate 包含 element 字段，并通过无参构造函数强制其初始化，该 构造函数又调用抽象的 create() 方法。这种创建方式可以在子类中定义，同时建立 T 的类型。

==泛型数组==

​		我们无法创建泛型数组。通用解决方案是在试 图创建泛型数组的时候使用 ArrayList这样做可以获得数组的行为，并且还具有泛型提供的编译时类型安全性。

​		有时，**仍然会创建泛型类型的数组**（例如，ArrayList 在内部使用数组）。可以通 过使编译器满意的方式定义对数组的通用引用

​		成功创建泛型类型的数组的唯一方法是创建一个已擦除 类型的新数组，并将其强制转换。

​		和以前一样，我们不能说 T[] array = new T[sz] ，所以我们创建了一个 Object 数组并将其强制转换。由于擦除，数组的运行时类型只能是 Object[] 。如果我们立即将其转换为 T[] ， 则在编译时会丢失数组的实际类型，并且编译器可能会错过一些潜在的错误检查。**因 此，最好在集合中使用 Object[] ，并在使用数组元素时向 T 添加强制类型转换。让**

==类型标记Class<T>==实现了 T[ ] 

​		类型标记 Class 被传递到构造函数中以从擦除中恢复，因此尽管必须使用 @SuppressWarnings 关闭来自强制类型转换的警告，但我们仍可以创建所需的实际 数组类型。一旦获得了实际的类型，就可以返回它并产生所需的结果，如在主方法中看 到的那样。数组的运行时类型是确切的类型 T[] 。

==边界==

​		边界允许我们对泛型使用的参数类 型施加约束。尽管这可以强制执行有关应用了泛型类型的规则，但潜在的更重要的效果 是我们可以在绑定的类型中调用方法

​		由于擦除会删除类型信息，因此唯一可用于无限制泛型参数的方法是那些 Object 可用的方法。但是，如果将该参数限制为某类型的子集，则可以调用该子集中的方法。 为了应用约束，Java 泛型使用了 extends 关键字。重要的是要理解，当用于限定泛型类型时，extends 的含义与通常的意义截然不同。

==通配符==

​		在泛型参数表达式中 的问号，在 类型信息 一章中这种示例更多。你可以将派生类的数组赋值给基类的 引用

​		问题： 就是通过继承后向上转型的行为把其他对象放到
​		所以很明显，数组对象可 以保留有关它们包含的对象类型的规则。看起来就像数组对它们持有的对象是有意识 的，因此在编译期检查和运行时检查之间，你不能滥用它们。但 是泛型的主要目标之一是将这种错误检测移到编译期。

​		但是，有时你想在两个类型间建立某种向上转型关系。通配符可以产生这种关系。flist 的类型现在是 List，你可以读作 “**一个具有任何从 Fruit 继承的类型的列表**”。通配符引用的是明确的类型，因此它意味着 “某种 flist 引用没有指定的具体类型”。

==编译器有多聪明==

​		我们发现编译器没有那么聪明、为了禁止对类型中使用了通配符的方法调用，**需要在参数列表 中使用类型参数**。编**译器只关注传递进来和要返回的对象类型**。它不会分析代码，以查看是否执行 了任何实际的写入和读取操作。

==逆变==可以声明通配符是由某个特 定类的任何基类来界定的，方法是指定 <？super MyClass> ，或者甚至使用类型参 数：<？super T>

==无界通配符==

​		无界通配符  看起来意味着 “任何事物”，因此使用无界通配符好像等价于使用 原生类型。

==捕获转换==

​		有一种特殊情况需要使用<?>  而不是原生类型。如果向一个使用  的方法传递 原生类型，那么对编译器来说，可能会推断出实际的类型参数，使得这个方法可以回转 并调用另一个使用这个确切类型的方法。下面的示例演示了这种技术，它被称为捕获转 换

​		举例：

​			f1() 中的类型参数都是确切的，没有通配符或边界。在 f2() 中，Holder 参数是 一个无界通配符，因此它看起来是未知的。但是，在 f2() 中调用了 f1()，而 f1() 需 要一个已知参数。这里所发生的是：在调用 f2() 的过程中捕获了参数类型，并在调用 f1() 时使用了这种类型。你可能想知道这项技术是否可以用于写入，但是这要求在传 递 Holder 时同时传递一个具体类型。捕获转换只有在这样的情况下可以工作：即 在方法内部，你需要使用确切的类型。注意，不能从 f2() 中返回 T，因为 T 对于 f2() 来说是未知的。捕获转换十分有趣，但是非常受限。

==问题== 

		1. 任何基本类型都不能作为类型参数（正如本章早先提到的，Java 泛型的限制之一是不能将基本类型用作类型参数。因 此，不能创建 ArrayList 之类的东西。解决方法是使用基本类型的包装器类以及 自动装箱机制。如果创建一个 ArrayList，但是如果性能成为问题的话，就需要使用专门为基本类型适配的特殊版本 的集合；）
		1. 实现参数化接口：一个类不能实现同一个泛型接口的两种变体，由于擦除的原因，这两个变体会成为 相同的接口
		1. 转型和警告 使用带有泛型类型参数的转型或 instanceof 不会有任何效果。
		1. 重载  下面的程序是不能编译的，即使它看起来是合理的：因为擦除，所以重载方法产生了相同的类型签名。幸运的是，编译器可以检测到这类问题。
		1. 基类劫持接口   假设你有一个实现了 Comparable 接口的 Pet 类

==自限定的类型==

​		在 Java 泛型中，有一个似乎经常性出现的惯用法，它相当令人费解： class SelfBounded<T extends SelfBounded<T>> { // ...这就像两面镜子彼此照向对方所引起的目眩效果一样，是一种无限反射。SelfBounded 类接受泛型参数 T，而 T 由一个边界类限定，这个边界就是拥有 T 作为 其参数的 SelfBounded。

==古怪的循环泛型==

​		为了理解自限定类型的含义，我们从这个惯用法的一个简单版本入手，它没有自限 定的边界。 不能直接继承一个泛型参数，但是，可以继承在其自己的定义中使用这个泛型参数 的类。也就是说，可以声明

​		注意，这里有些东西很重要：新类 Subtype 接受的参数和返回的值具有 Subtype 类型而不仅仅是基类 BasicHolder 类型。这就是 CRG 的本质：基类用导出类替代其 参数。这意味着泛型基类变成了一种其所有导出类的公共功能的模版，但是这些功能对 于其所有参数和返回值，将使用导出类型。也就是说，在所产生的类中将使用确切类型 而不是基类型。因此，在 Subtype 中，传递给 set() 的参数和从 get() 返回的类型都 是确切的 Subtype。

==自限定==

​		BasicHolder 可以使用任何类型作为其泛型参数、限定将采取额外的步骤，强制泛型当作其自身的边界参数来使用。自限定所做的，就是要求在继承关系中，像下面这样使用这个类  class A extends SelfBounded{}这会强制要求将正在定义的类当作参数传递给基类。

​		它可以保证类型参数必须与正在被定义的类相同。正 如你在 B 类的定义中所看到的，还可以从使用了另一个 SelfBounded 参数的 SelfBounded 中导出，尽管在 A 类看到的用法看起来是主要的用法。对定义 E 的尝试说 明不能使用不是 SelfBounded 的类型参数。遗憾的是，F 可以编译，不会有任何警告， 因此自限定惯用法不是可强制执行的。如果它确实很重要，可以要求一个外部工具来确 保不会使用原生类型来替代参数化类型。

==参数协变==  **自限定类型的价值**在于它们可以产生协变参数类型——方法参数类型会随子类而 变化。

==动态类型安全==

​		Java 5 的 java.util.Collections 中有一组便利工具，可以解决在这种情况下的类 型检查问题，它们是：静态方法 checkedCollection() 、checkedList()、checkedMap() 、checkedSet() 、checkedSortedMap() 和 checkedSortedSet()。这些方法每一个都 会将你希望动态检查的集合当作第一个参数接受，并将你希望强制要求的类型作为第二 个参数接受。==泛型异常==

​		由于擦除的原因，catch 语句不能捕获泛型类型的异常，因为在编译期和运行时都 必须知道异常的确切类型。泛型类也不能直接或间接继承自 Throwable（这将进一步 阻止你去定义不能捕获的泛型异常）。但是，类型参数可能会在一个方法的 throws 子 句中用到。这使得你可以编写随检查型异常类型变化的泛型代码		



​		