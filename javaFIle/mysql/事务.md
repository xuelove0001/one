##### 一：事务

1. 概述
   1. 什么是事务？一个事务其实就是一个完整得业务逻辑。要么同时成功、要么同时失败、不可再分
   2. 只有DMl语句才和事务有关系、其它语句和事务无关！！！
      1. insert
      2. delete
      3. update
   3. 事务是怎么做到多条DML语句同时成功和同时失败的呢？
      1. InnoDB存储引擎：提供一组用来记录事务性活动的日志文件
      2. 开启事务——》会在日志文件中记录下来——
      3. 提交事务——》清空事务性活动的日志文件、将数据全部彻底持久化到数据库表中
         1. 提交事务标志着、事务的结束。并且是一种全部成功的结束
      4. 回滚事务——》清空事务性活动的日志文件、将之前所有的DML操作全部撤销、回滚事务标志事务的结束
         1. 并且是一种全部失败的结束
      5. 怎么提交事务、怎么回滚事务？
         1. 提交事务：commit；语句
         2. 回滚事务：rollback;  语句（每次只是回滚到上一次提交点）
      6. 事务(transaction)
   4. mysql默认情况下是支持自动提交事务的。(自动提交)
      1. 什么是自动提交？
      2. 每执行一条DML语句、则提交一次
      3. 关闭mysql默认自动提交机制(start  transaction)
   5. 地方
2. 事务包括4个特性？
   1. A：原子性
      1. 说明事务最小的工作单元、不可再分
   2. C：一致性
      1. 所有事务要求、在同一个事务当中、
      2. 所有操作必须同时成功、或者同时失败
      3. 以保证数据的一致性
   3. I：隔离性
      1. A事务和B事务之间具有一定的隔离。
      2. A事务在操作一张表的时候、另一个事务B也操作这张表会那样？？？
   4. D：持久性
      1. 事务最终结束的一个保障、事务提交、就相当与将没有保存到表中的数据
      2. 保存在硬盘上
3. 隔离级别（隔离性的分支）
   1. MySQL8改成了transaction_isolation,之前是tx_isolation
   2. 事务与事务之间的隔离级别有哪些呢？4个级别
   3. 读未提交： read uncommitted （最低的隔离级别）
      1. 事务A可以读取到事务B未提交的数据。
      2. 这种隔离级别存在的问题就是：脏读现象！(Dirty  Read) 我们称读到了脏数据
      3. 设置全局的：set global transaction isolation level read uncommitted
   4. 读已提交：read  committed
      1. 事务A只能读取到事务B提交之后的数据。
      2. 这种隔离级别解决了   脏读  的现象。
      3. 这种隔离级别存在的问题？不可重复读取数据。
      4. 这种隔离级别是比较真实的数据、每一次读到的数据是绝对的真实。
      4. set global transaction isolation level read committed
   5. 可重复读：repeatable  read
      1. 事务A开启之后、不管是多久、每一次在事务A中读取的数据都是一致的，
      2. 即使事务B将数据已经修改、并且提交了、事务A读取到的数据还是没有发生改变，可重复读
      3. 解决了不可重复读取
      4. 存在的问题？幻影读，每一次读取到的数据都是幻影，不够真实！
      4. set global transaction isolation level  repeatable  read;
   6. 序列化读/串行化：serializable    （最高的隔离级别）
      1. 这是最高隔离级别、效率最低、解决了所有的问题。
      2. 这中隔离级别表示事务在排队，不能并发
      2. set global transaction isolation level read serializable
4. 