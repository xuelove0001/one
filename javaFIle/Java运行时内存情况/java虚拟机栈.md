Java虚拟机栈

与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stack）也是线程私有的，它的生命周期
与线程相同。虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都
会同步创建一个栈帧[1]（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信
息。

<mark>方法</mark>每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。<mark>（java执行方式时栈会同时创建栈帧存放在栈内）</mark>

当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定
的，在方法运行期间不会改变局部变量表的大小。（大小指栈的最小单位slot）

。请读者注意，这里说的“大小”是指变量槽的数量，虚拟机真正使用多大的内存空间（譬如按照1个变量槽占用32个比特、64个比特，或者更多）来实现一个变量槽，这是完全由具体的虚拟机实现自行决定的事情。

<mark>局部变量表</mark>存放了编译期可知的各种Java虚拟机基本数据类型（boolean、byte、char、short、int、
float、long、double）、

<mark>对象引用</mark>（reference类型，它并不等同于对象本身，可能是一个指向对象起始
地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）（有三种情况）和returnAddress类型（指向了一条字节码指令的地址）。

数据类型：这些数据类型在局部变量表中的存储空间以局部变量槽（Slot）来表示，其中64位长度的long和double类型的数据会占用两个变量槽，其余的数据类型只占用一个。

<mark>局部变量</mark>表所需的内存空间在<mark>编译期间</mark>完成分配。

栈是否支持动态扩展

《Java虚拟机规范》明确允许Java虚拟机实现自行选择是否支持栈的动态扩展，而HotSpot虚拟机的选择是不支持扩展，所以除非在创建线程申请内存时就因无法获得足够内存而出现
OutOfMemoryError异常，否则在线程运行时是不会因为扩展而导致内存溢出的，只会因为栈容量无法容纳新的栈帧而导致StackOverflowError异常。
