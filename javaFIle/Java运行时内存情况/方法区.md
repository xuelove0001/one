方法区

方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。

<mark>方法的设计</mark>

说到方法区，不得不提一下“永久代”这个概念，尤其是在JDK 8以前，许多Java程序员都习惯在HotSpot虚拟机上开发、部署程序，很多人都更愿意把方法区称呼为“永久代（Permanent
Generation），或将两者混为一谈。本质上这两者并不是等价的，（永久代 != 方法区）

因为仅仅是当时的HotSpot虚拟机设
计团队选择把收集器的分代设计扩展至方法区，或者说使用永久代来实现方法区而已，这样使得HotSpot的垃圾收集器能够像管理Java堆一样管理这部分内存，省去专门为方法区编写内存管理代码的工作。譬如BEA JRockit、IBM J9等来说，是不存在永久代的概念的。

比较： 而J9和JRockit只要没有触碰到进程可用内存的上限，例如32位系统中的4GB限制，就不会出问题），而且有极少数方法（例如String::intern()）会因永久代的原因而导致不同虚拟机下有不同的表现。

<mark>设计方法区</mark>：在JDK 6的时候HotSpot开发团队就有放弃永久代，逐步改为采用本地内存（Native Memory）来实现方法区的计划了[1逐步改为采用本地内存（Native Memory）来实现方法区的计划了[1]，

到了JDK 7的HotSpot，已经把原本放在永久代的字符串常量池、静态变量等移出，而到了
JDK 8，终于完全废弃了永久代的概念，<mark>改用与JRockit、J9一样在本地内存中实现的元空间（Metaspace）来代替</mark>，把JDK 7中永久代还剩余的内容（主要是类型信息）全部移到元空间中。

《Java虚拟机规范》对方法区的约束是非常宽松的，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，甚至还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域的确是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。

<mark>方法区的回收</mark>：这区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一

例如： 对类型的卸载难，以前Sun公司的Bug列
表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏(系统**内存**的浪费导致程序运行速度减慢)。
